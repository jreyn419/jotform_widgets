<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EMS Inventory Checklist</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }
    
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
    }
    
    .widget-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      max-height: 100vh;
      background: #f5f5f5;
    }

    .widget-header {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding: 4px 10px;
      background: #f5f5f5;
      flex-shrink: 0;
    }

    .settings-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px;
      font-size: 18px;
      color: #999;
      border-radius: 4px;
      line-height: 1;
      transition: color 0.15s, background 0.15s;
    }

    .settings-btn:hover {
      color: #555;
      background: #e9ecef;
    }

    /* Reset Dialog */
    .reset-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .reset-overlay.open {
      display: flex;
    }

    .reset-dialog {
      background: white;
      border-radius: 12px;
      width: 90%;
      max-width: 340px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.25);
      overflow: hidden;
    }

    .reset-dialog-header {
      padding: 16px 20px 12px;
      font-size: 16px;
      font-weight: 700;
      color: #333;
      border-bottom: 1px solid #eee;
    }

    .reset-dialog-body {
      padding: 16px 20px;
    }

    .reset-option {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      padding: 12px;
      margin-bottom: 8px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      cursor: pointer;
      transition: border-color 0.15s, background 0.15s;
    }

    .reset-option:hover {
      background: #f8f9fa;
    }

    .reset-option.selected {
      border-color: #dc3545;
      background: #fff5f5;
    }

    .reset-option.selected.restore {
      border-color: #0066cc;
      background: #e7f3ff;
    }

    .reset-option input[type="radio"] {
      margin-top: 2px;
      accent-color: #dc3545;
      flex-shrink: 0;
    }

    .reset-option-label {
      font-size: 14px;
      font-weight: 600;
      color: #333;
    }

    .reset-option-desc {
      font-size: 12px;
      color: #777;
      margin-top: 2px;
    }

    .reset-dialog-footer {
      display: flex;
      gap: 8px;
      padding: 12px 20px 16px;
      justify-content: flex-end;
    }

    .reset-cancel-btn {
      padding: 8px 16px;
      background: #f0f0f0;
      border: none;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      color: #555;
    }

    .reset-cancel-btn:hover {
      background: #e0e0e0;
    }

    .reset-confirm-btn {
      padding: 8px 16px;
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      opacity: 0.5;
      pointer-events: none;
    }

    .reset-confirm-btn.enabled {
      opacity: 1;
      pointer-events: auto;
    }

    .reset-confirm-btn.enabled:hover {
      background: #c82333;
    }
    

    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-height: 0;
    }
    
    .areas-container {
      flex: 1;
      overflow-y: auto;
      padding: 0;
      min-height: 0;
      position: relative;
    }
    
    /* Area sections */
    .area-section {
      background: white;
      border-radius: 8px;
      margin: 0 10px 10px 10px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      overflow: visible;
    }

    .area-section.expanded {
      border-radius: 0;
    }

    .areas-container > .area-section:first-child,
    .areas-container > .area-group:first-child {
      margin-top: 10px;
    }

    /* Parent area group — contains child area-sections */
    .area-group {
      background: #dce2e8;
      border-radius: 8px;
      margin: 0 10px 10px 10px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.15);
      overflow: visible;
    }

    .area-group.expanded {
      border-radius: 0;
    }

    .area-group > .area-header {
      background: #dee4ea;
      font-size: 15px;
      
    }

    .area-group > .area-header:hover {
      background: #d0d8e0;
    }

    .area-group > .area-header.has-issues {
      background: #fff3cd;
      border-left: 4px solid #ffc107;
    }

    .area-group > .area-header.all-ok {
      background: #d4edda;
      border-left: 4px solid #28a745;
    }

    .area-group > .area-header.tagged {
      background: #d1ecf1;
      border-left: 4px solid #17a2b8;
    }

    .area-group.expanded > .area-header {
      position: sticky;
      top: 0;
      z-index: 11;
      border-radius: 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .area-group > .area-group-content {
      display: none;
      padding: 8px;
    }

    .area-group.expanded > .area-group-content {
      display: block;
    }

    .area-group > .area-group-content > .area-section {
      box-shadow: 0 1px 2px rgba(0,0,0,0.08);
      margin-left: 0;
      margin-right: 0;
    }

    /* Ensure seal buttons inside child areas have breathing room */
    .area-group > .area-group-content > .area-section > .area-content {
      padding-bottom: 4px;
    }

    .area-group.expanded > .area-group-content > .area-section.expanded > .area-header {
      /* top value set dynamically by updateStickyOffsets() */
      z-index: 10;
    }

    .area-group.expanded > .area-group-content > .area-section.expanded .category-header {
      /* top value set dynamically by updateStickyOffsets() */
      z-index: 9;
    }

    .area-group.expanded > .area-group-content > .area-section.expanded .subcategory-header {
      /* top value set dynamically by updateStickyOffsets() */
      z-index: 8;
    }

    .parent-own-items {
      background: white;
      border-radius: 0;
      margin-bottom: 8px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.08);
      overflow: visible;
    }

    /* Category/subcategory headers inside parent-own-items are always visible
       (no expand/collapse on the parent-own-items wrapper), so always sticky */
    .area-group.expanded .parent-own-items .category-header {
      position: sticky;
      /* top value set dynamically by updateStickyOffsets() */
      z-index: 9;
    }

    .area-group.expanded .parent-own-items .subcategory-header {
      position: sticky;
      /* top value set dynamically by updateStickyOffsets() */
      z-index: 8;
    }
    
    .area-header {
      display: flex;
      align-items: center;
      padding: 12px 15px;
      background: #f8f9fa;
      cursor: pointer;
      user-select: none;
      border-bottom: 1px solid #eee;
      gap: 10px;
      flex-shrink: 0;
      border-radius: 8px;
    }

    .area-section.expanded .area-header {
      border-radius: 0;
    }
    
    .area-header:hover {
      background: #e9ecef;
    }
    
    .area-header.has-issues {
      background: #fff3cd;
      border-left: 4px solid #ffc107;
    }
    
    .area-header.all-ok {
      background: #d4edda;
      border-left: 4px solid #28a745;
    }
    
    .area-section.expanded .area-header {
      position: sticky;
      top: 0;
      z-index: 10;
      border-radius: 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .collapse-icon {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: #666;
      transition: transform 0.2s;
      flex-shrink: 0;
    }
    
    .area-section.expanded .collapse-icon {
      transform: rotate(90deg);
    }
    
    .area-title {
      flex: 1;
      font-weight: 600;
      font-size: 14px;
      color: #333;
    }
    
    .area-status {
      font-size: 12px;
      padding: 3px 8px;
      border-radius: 12px;
      background: #e9ecef;
      color: #666;
    }
    
    .area-status.issues {
      background: #dc3545;
      color: white;
    }
    
    .area-status.ok {
      background: #28a745;
      color: white;
    }
    
    .area-content {
      display: none;
      overflow: visible;
      border-top: 1px solid #eee;
    }

    .category-items {
      overflow: visible;
    }

    .subcategory-items {
      overflow: visible;
    }
    
    .area-section.expanded .area-content {
      display: block;
    }
    
    /* Category within area */
    .category-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 15px;
      background: #f0f0f0;
      font-size: 12px;
      font-weight: 600;
      color: #555;
      border-bottom: 1px solid #e0e0e0;
      transition: background 0.2s;
    }

    .category-header.category-complete {
      background: #e6f4ea;
      color: #1a7431;
    }

    .category-header.category-complete .category-status {
      color: #28a745;
      font-weight: 600;
    }

    .subcategory-header.category-complete {
      background: #edf7f0;
      color: #1a7431;
    }

    .subcategory-header.category-complete .category-status {
      color: #28a745;
      font-weight: 600;
    }
    
    .area-section.expanded .category-header {
      position: sticky;
      /* top value set dynamically by updateStickyOffsets() */
      z-index: 9;
    }
    
    .category-checkbox {
      width: 22px;
      height: 22px;
      cursor: pointer;
      accent-color: #28a745;
      flex-shrink: 0;
    }
    
    .category-status {
      margin-left: auto;
      font-weight: normal;
      color: #888;
    }
    
    /* Checklist items */
    .checklist-item {
      display: flex;
      align-items: center;
      padding: 10px 15px;
      border-bottom: 1px solid #f0f0f0;
      gap: 10px;
    }
    
    .checklist-item:last-child {
      border-bottom: none;
    }
    
    .checklist-item.checked {
      background: #f0fff0;
    }
    
    .checklist-item.short {
      background: #fffbeb;
    }
    
    .checklist-item.missing {
      background: #fff5f5;
    }
    
    .checklist-item.restocked {
      background: #f3e8ff;
    }
    
    .checklist-item.restocked .item-required {
      color: #7c3aed;
      background: #ede9fe;
    }
    
    .restocked-tag {
      display: flex;
      align-items: center;
      gap: 6px;
      background: #7c3aed;
      color: white;
      font-size: 12px;
      font-weight: 600;
      padding: 6px 10px;
      border-radius: 6px;
      flex-shrink: 0;
    }
    
    .restocked-tag .restocked-qty {
      opacity: 0.9;
    }
    
    .restocked-tag .restocked-remove {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      font-size: 14px;
      line-height: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      margin-left: 2px;
    }
    
    .restocked-tag .restocked-remove:hover {
      background: rgba(255,255,255,0.35);
    }
    
    .checklist-item.out-of-stock-item {
      background: #fef2f2;
    }
    
    .checklist-item.out-of-stock-item .item-required {
      color: #991b1b;
      background: #fecaca;
    }
    
    .out-of-stock-tag {
      display: flex;
      align-items: center;
      gap: 6px;
      background: #6c757d;
      color: white;
      font-size: 12px;
      font-weight: 600;
      padding: 6px 10px;
      border-radius: 6px;
      flex-shrink: 0;
    }
    
    .out-of-stock-tag .out-of-stock-remove {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      font-size: 14px;
      line-height: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      margin-left: 2px;
    }
    
    .out-of-stock-tag .out-of-stock-remove:hover {
      background: rgba(255,255,255,0.35);
    }
    
    .item-checkbox {
      width: 22px;
      height: 22px;
      cursor: pointer;
      accent-color: #28a745;
      flex-shrink: 0;
    }
    
    .item-info {
      flex: 1;
      min-width: 0;
    }
    
    .item-name {
      font-size: 14px;
      color: #333;
    }
    
    .item-required {
      font-size: 13px;
      font-weight: 600;
      color: #555;
      flex-shrink: 0;
      background: #f0f0f0;
      padding: 4px 8px;
      border-radius: 4px;
      white-space: nowrap;
    }
    
    .checklist-item.checked .item-required {
      color: #28a745;
      background: #e6f4ea;
    }
    
    .checklist-item.short .item-required {
      color: #b8860b;
      background: #fff3cd;
    }
    
    .checklist-item.missing .item-required {
      color: #dc3545;
      background: #fde8ea;
    }
    
    .qty-stepper {
      display: flex;
      align-items: center;
      border: 1px solid #ccc;
      border-radius: 6px;
      overflow: hidden;
      flex-shrink: 0;
    }
    
    .qty-btn {
      width: 36px;
      height: 36px;
      border: none;
      background: #f0f0f0;
      font-size: 18px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .qty-btn:hover {
      background: #e0e0e0;
    }
    
    .qty-btn:active {
      background: #d0d0d0;
    }
    
    .qty-value {
      width: 45px;
      height: 36px;
      border: none;
      border-left: 1px solid #ccc;
      border-right: 1px solid #ccc;
      text-align: center;
      font-size: 14px;
      font-weight: 600;
      -moz-appearance: textfield;
    }
    
    .qty-value::-webkit-outer-spin-button,
    .qty-value::-webkit-inner-spin-button {
      -webkit-appearance: none;
    }
    
    .shortage-badge {
      font-size: 11px;
      font-weight: 600;
      padding: 2px 6px;
      border-radius: 4px;
      background: #dc3545;
      color: white;
      margin-left: 5px;
    }
    
    .shortage-badge.warning {
      background: #ffc107;
      color: #333;
    }
    
    /* Fixed Footer Restock Button */
    .restock-footer {
      position: relative;
      flex-shrink: 0;
      padding: 10px 15px;
      background: #f5f5f5;
      border-top: 1px solid #ddd;
    }
    
    .restock-footer::before {
      content: '';
      position: absolute;
      top: -20px;
      left: 0;
      right: 0;
      height: 20px;
      pointer-events: none;
    }

    .restock-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      width: 100%;
      padding: 12px 20px;
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .restock-btn:hover {
      background: #c82333;
    }
    
    .restock-btn.all-ok {
      background: #28a745;
    }
    
    .restock-btn.all-ok:hover {
      background: #218838;
    }
    
    .restock-icon {
      font-size: 16px;
      font-weight: 700;
    }
    
    .restock-count {
      background: rgba(255,255,255,0.25);
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
    }
    
    /* Modal */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 200;
      justify-content: center;
      align-items: center;
      padding: 0;
    }
    
    .modal-overlay.open {
      display: flex;
    }
    
    .modal-content {
      background: white;
      border-radius: 0;
      width: 100%;
      height: 100%;
      max-width: 100%;
      max-height: 100%;
      display: flex;
      flex-direction: column;
      box-shadow: none;
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background: #333;
      color: white;
      border-radius: 0;
      flex-shrink: 0;
    }
    
    .modal-header h2 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
    }
    
    .modal-close {
      background: none;
      border: none;
      color: white;
      font-size: 28px;
      cursor: pointer;
      line-height: 1;
      padding: 0;
      opacity: 0.7;
    }
    
    .modal-close:hover {
      opacity: 1;
    }
    
    .modal-body {
      flex: 1;
      overflow-y: auto;
      min-height: 0;
      padding-bottom: 80px;
    }
    
    .modal-footer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 15px 20px;
      background: white;
      border-top: 1px solid #eee;
      box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
      z-index: 5;
    }
    
    .restock-all-btn {
      width: 100%;
      padding: 16px 20px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .restock-all-btn:hover {
      background: #218838;
    }
    
    .restock-all-btn:active {
      background: #1e7e34;
    }
    

    .summary-empty {
      padding: 20px;
      text-align: center;
      color: #28a745;
      font-size: 14px;
    }
    
    .summary-empty .icon {
      font-size: 32px;
      margin-bottom: 8px;
    }
    
    .shortage-group {
      border-bottom: none;
    }
    
    .shortage-group:last-child {
      border-bottom: none;
    }

    .shortage-cat-section {
      /* Scoping container for each top-level category so that sticky
         subcategory headers unstick when scrolling past their category */
    }

    .shortage-group-header {
      padding: 12px 15px;
      background: #333;
      color: white;
      font-size: 14px;
      font-weight: 600;
      border-bottom: 1px solid #222;
      position: sticky;
      top: 0;
      z-index: 3;
    }

    .shortage-cat-header {
      padding: 8px 15px;
      background: #f0f0f0;
      font-size: 12px;
      font-weight: 600;
      color: #555;
      border-bottom: 1px solid #e0e0e0;
      position: sticky;
      /* top set dynamically by updateModalStickyOffsets() */
      z-index: 2;
    }

    .shortage-subcat-header {
      padding: 6px 15px 6px 30px;
      background: #f5f5f5;
      font-size: 11px;
      font-weight: 600;
      color: #666;
      border-bottom: 1px solid #e8e8e8;
      position: sticky;
      /* top set dynamically by updateModalStickyOffsets() */
      z-index: 1;
    }
    
    .shortage-item {
      display: flex;
      align-items: center;
      padding: 10px 15px;
      border-bottom: 1px solid #f0f0f0;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .shortage-item:last-child {
      border-bottom: none;
    }
    
    .shortage-item.restocked {
      background: #d4edda;
      opacity: 0.7;
    }
    
    .shortage-item.out-of-stock {
      background: #f8d7da;
    }
    
    .shortage-item-qty {
      font-size: 13px;
      font-weight: 600;
      flex-shrink: 0;
      padding: 4px 8px;
      border-radius: 4px;
      white-space: nowrap;
      background: #fde8ea;
      color: #dc3545;
    }

    .shortage-item-qty.partial {
      background: #fff3cd;
      color: #b8860b;
    }

    .shortage-item-qty.handled {
      background: #e6f4ea;
      color: #28a745;
    }
    
    .shortage-item-name {
      font-size: 14px;
      font-weight: 500;
      color: #333;
      flex: 1;
      min-width: 0;
    }
    
    .shortage-item-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .shortage-item-need {
      display: none;
    }
    
    .shortage-item-need.partial {
      background: #ffc107;
      color: #333;
    }
    
    .shortage-item-actions {
      display: flex;
      gap: 8px;
      flex: 1;
      justify-content: flex-end;
    }
    
    .action-btn {
      padding: 8px 14px;
      border: none;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 5px;
      transition: all 0.15s;
      justify-content: center;
    }
    
    .action-btn.restock {
      background: #28a745;
      color: white;
    }
    
    .action-btn.restock:hover {
      background: #218838;
    }
    
    .action-btn.out-of-stock {
      background: #6c757d;
      color: white;
    }
    
    .action-btn.out-of-stock:hover {
      background: #5a6268;
    }
    
    .action-btn.undo {
      background: #e9ecef;
      color: #333;
      min-width: auto;
      padding: 6px 12px;
    }
    
    .action-btn.undo:hover {
      background: #dee2e6;
    }
    
    .shortage-item-status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      flex-wrap: wrap;
    }
    
    .shortage-item-status.restocked {
      background: #c3e6cb;
      color: #155724;
    }
    
    .shortage-item-status.unavailable {
      background: #f5c6cb;
      color: #721c24;
    }
    
    .status-reason {
      font-weight: normal;
      font-style: italic;
      opacity: 0.9;
    }
    
    /* Out of Stock Dialog */
    .dialog-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.6);
      z-index: 300;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }
    
    .dialog-overlay.open {
      display: flex;
    }
    
    .dialog-content {
      background: white;
      border-radius: 12px;
      width: 100%;
      max-width: 400px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    }
    
    .dialog-header {
      padding: 15px 20px;
      border-bottom: 1px solid #eee;
    }
    
    .dialog-header h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      color: #333;
    }
    
    .dialog-body {
      padding: 20px;
    }
    
    .dialog-item-name {
      font-weight: 600;
      color: #333;
      margin: 0 0 15px 0;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 6px;
    }
    
    .dialog-body label {
      display: block;
      font-size: 14px;
      color: #666;
      margin-bottom: 10px;
    }
    
    .reason-buttons {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .reason-btn {
      padding: 14px 16px;
      border: 2px solid #dee2e6;
      border-radius: 8px;
      background: white;
      font-size: 14px;
      font-weight: 500;
      color: #333;
      cursor: pointer;
      text-align: left;
      transition: all 0.15s;
    }
    
    .reason-btn:hover {
      border-color: #adb5bd;
      background: #f8f9fa;
    }
    
    .reason-btn.selected {
      border-color: #0066cc;
      background: #e7f3ff;
      color: #0066cc;
    }
    
    .other-reason-container {
      display: none;
      margin-top: 12px;
    }
    
    .other-reason-container.visible {
      display: block;
    }
    
    .dialog-body textarea {
      width: 100%;
      height: 80px;
      padding: 12px;
      border: 2px solid #dee2e6;
      border-radius: 8px;
      font-size: 14px;
      font-family: inherit;
      resize: none;
    }
    
    .dialog-body textarea:focus {
      outline: none;
      border-color: #0066cc;
    }
    
    .dialog-footer {
      padding: 15px 20px;
      border-top: 1px solid #eee;
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
    
    .dialog-btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
    }
    
    .dialog-btn.cancel {
      background: #e9ecef;
      color: #333;
    }
    
    .dialog-btn.cancel:hover {
      background: #dee2e6;
    }
    
    .dialog-btn.confirm {
      background: #dc3545;
      color: white;
    }
    
    .dialog-btn.confirm:hover:not(:disabled) {
      background: #c82333;
    }
    
    .dialog-btn.confirm:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    /* Tagged/Sealed Area */
    .area-header.tagged {
      background: #d1ecf1;
      border-left: 4px solid #17a2b8;
    }

    .area-header.tagged:hover {
      background: #bee5eb;
    }

    .area-header.tagged.review-needed {
      background: #fff3cd;
      border-left: 4px solid #fd7e14;
    }

    .area-header.tagged.review-needed:hover {
      background: #ffe8a1;
    }

    .area-status.tagged {
      background: #17a2b8;
      color: white;
    }

    .area-status.review-needed {
      background: #fd7e14;
      color: white;
    }

    .tagged-panel {
      padding: 24px 20px;
      text-align: center;
      background: #f0fafb;
    }

    .tagged-panel.review-needed {
      background: #fffbf0;
    }

    .tagged-panel .seal-icon {
      font-size: 48px;
      margin-bottom: 8px;
    }

    .tagged-panel .seal-title {
      font-size: 18px;
      font-weight: 700;
      color: #0c5460;
      margin-bottom: 6px;
    }

    .tagged-panel.review-needed .seal-title {
      color: #856404;
    }

    .tagged-panel .seal-date {
      font-size: 14px;
      color: #555;
      margin-bottom: 4px;
    }

    .tagged-panel .seal-days {
      font-size: 13px;
      color: #888;
      margin-bottom: 16px;
    }

    .tagged-panel .seal-warning {
      background: #d1ecf1;
      border: 1px solid #bee5eb;
      border-radius: 8px;
      padding: 12px 16px;
      margin: 0 auto 16px auto;
      max-width: 320px;
      font-size: 13px;
      color: #0c5460;
      font-weight: 500;
      text-align: center;
    }

    .tagged-panel .seal-expired-warning {
      background: #f8d7da;
      border: 1px solid #f5c6cb;
      border-radius: 8px;
      padding: 12px 16px;
      margin: 0 auto 16px auto;
      max-width: 320px;
      font-size: 13px;
      color: #721c24;
      font-weight: 600;
      text-align: center;
    }

    .seal-actions {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .break-seal-btn {
      padding: 12px 24px;
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s;
    }

    .break-seal-btn:hover {
      background: #c82333;
    }

    .break-seal-btn:active {
      background: #bd2130;
    }

    .seal-missing-btn {
      padding: 12px 24px;
      background: #fd7e14;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s;
    }

    .seal-missing-btn:hover {
      background: #e8590c;
    }

    .seal-missing-btn:active {
      background: #d9480f;
    }

    .tag-area-btn {
      display: none;
      width: calc(100% - 30px);
      margin: 12px auto;
      padding: 12px;
      background: #17a2b8;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s;
      margin-bottom: 15px;
    }

    .tag-area-btn:hover {
      background: #138496;
    }

    .tag-area-btn:active {
      background: #117a8b;
    }

    /* Completion Popup */
    .completion-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255,255,255,0.97);
      z-index: 400;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      padding: 30px;
      text-align: center;
    }

    .completion-overlay.open {
      display: flex;
    }

    .completion-close {
      position: absolute;
      top: 15px;
      right: 20px;
      background: none;
      border: none;
      font-size: 32px;
      color: #666;
      cursor: pointer;
      line-height: 1;
      padding: 0;
    }

    .completion-close:hover {
      color: #333;
    }

    .completion-icon {
      font-size: 64px;
      margin-bottom: 16px;
    }

    .completion-title {
      font-size: 24px;
      font-weight: 700;
      color: #28a745;
      margin-bottom: 12px;
    }

    .completion-message {
      font-size: 16px;
      color: #555;
      line-height: 1.5;
      max-width: 340px;
    }

    /* Seal All Button */
    .seal-all-btn {
      width: 100%;
      padding: 16px 20px;
      background: #17a2b8;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin-top: 10px;
    }

    .seal-all-btn:hover {
      background: #138496;
    }

    .seal-all-btn:active {
      background: #117a8b;
    }

    /* Collapsible Categories */
    .category-header {
      cursor: pointer;
      user-select: none;
    }

    .category-collapse-icon {
      width: 14px;
      height: 14px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: #888;
      transition: transform 0.2s;
      flex-shrink: 0;
    }

    /* Subcategory */
    .subcategory-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 15px 6px 30px;
      background: #f5f5f5;
      font-size: 11px;
      font-weight: 600;
      color: #666;
      border-bottom: 1px solid #e8e8e8;
      cursor: pointer;
      user-select: none;
    }

    .area-section.expanded .subcategory-header {
      position: sticky;
      /* top value set dynamically by updateStickyOffsets() */
      z-index: 8;
    }

    .subcategory-header .category-collapse-icon {
      font-size: 9px;
      width: 12px;
      height: 12px;
    }

    .subcategory-header .category-checkbox {
      width: 14px;
      height: 14px;
    }

    .subcategory-items .checklist-item {
      padding-left: 30px;
    }

    /* Changelog Overlay */
    .changelog-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 1100;
      align-items: center;
      justify-content: center;
    }

    .changelog-overlay.open {
      display: flex;
    }

    .changelog-dialog {
      background: white;
      border-radius: 12px;
      width: 90%;
      max-width: 400px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 30px rgba(0,0,0,0.25);
      overflow: hidden;
    }

    .changelog-header {
      padding: 16px 20px 12px;
      font-size: 16px;
      font-weight: 700;
      color: #333;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }

    .changelog-close {
      background: none;
      border: none;
      font-size: 22px;
      color: #999;
      cursor: pointer;
      line-height: 1;
      padding: 0 2px;
    }

    .changelog-close:hover {
      color: #333;
    }

    .changelog-body {
      flex: 1;
      overflow-y: auto;
      padding: 0;
    }

    .changelog-version {
      border-bottom: 1px solid #eee;
    }

    .changelog-version:last-child {
      border-bottom: none;
    }

    .changelog-version-header {
      padding: 10px 20px;
      background: #f8f9fa;
      display: flex;
      align-items: baseline;
      gap: 8px;
    }

    .changelog-version-number {
      font-size: 14px;
      font-weight: 700;
      color: #333;
    }

    .changelog-version-date {
      font-size: 11px;
      color: #999;
    }

    .changelog-changes {
      padding: 6px 20px 12px 36px;
      margin: 0;
      list-style: disc;
    }

    .changelog-changes li {
      font-size: 13px;
      color: #555;
      line-height: 1.5;
      margin-bottom: 2px;
    }

    .version-link {
      font-size: 11px;
      color: #aaa;
      cursor: pointer;
      text-decoration: none;
      transition: color 0.15s;
    }

    .version-link:hover {
      color: #555;
      text-decoration: underline;
    }

</style>
</head>
<body>
  <div class="widget-container">

    <div class="widget-header">
      <button class="settings-btn" onclick="openResetDialog()" title="Settings">&#9881;</button>
    </div>

    <div class="main-content">
      <div class="areas-container" id="areasContainer">
        <!-- Areas will be generated here -->
      </div>
      
    </div>
    
    <!-- Fixed Footer Restock Button -->
    <div class="restock-footer">
      <button class="restock-btn" id="restockBtn" onclick="openRestockModal()">
        <span class="restock-icon">!</span>
        <span>Restock</span>
        <span class="restock-count" id="restockCount">0</span>
      </button>
    </div>
    
    <!-- Restock Modal -->
    <div class="modal-overlay" id="modalOverlay" onclick="closeRestockModal()">
      <div class="modal-content" onclick="event.stopPropagation()">
        <div class="modal-header">
          <h2>Items to Restock</h2>
          <button class="modal-close" onclick="closeRestockModal()">×</button>
        </div>
        <div class="modal-body" id="summaryContent">
          <div class="summary-empty">
            <div class="icon">✓</div>
            <div>All items fully stocked!</div>
          </div>
        </div>
        <div class="modal-footer" id="modalFooter">
          <button class="restock-all-btn" onclick="restockAllItems()">
            <span>✓</span> Mark All Restocked
          </button>
          <button class="seal-all-btn" id="sealAllBtn" onclick="sealAllAreas()" style="display:none">
            <span>&#x1F512;</span> Seal All Eligible Areas
          </button>
        </div>
      </div>
    </div>
    
    <!-- Out of Stock Explanation Dialog -->
    <div class="dialog-overlay" id="dialogOverlay" onclick="closeOutOfStockDialog()">
      <div class="dialog-content" onclick="event.stopPropagation()">
        <div class="dialog-header">
          <h3>Item Unavailable</h3>
        </div>
        <div class="dialog-body">
          <p class="dialog-item-name" id="dialogItemName"></p>
          <label>Select reason:</label>
          <div class="reason-buttons">
            <button class="reason-btn" onclick="selectReason(this, 'National shortage')">National shortage</button>
            <button class="reason-btn" onclick="selectReason(this, 'Equipment being fixed')">Equipment being fixed</button>
            <button class="reason-btn" onclick="selectReason(this, 'other')">Other</button>
          </div>
          <div class="other-reason-container" id="otherReasonContainer">
            <textarea id="outOfStockReason"></textarea>
          </div>
        </div>
        <div class="dialog-footer">
          <button class="dialog-btn cancel" onclick="closeOutOfStockDialog()">Cancel</button>
          <button class="dialog-btn confirm" id="confirmBtn" onclick="confirmOutOfStock()" disabled>Confirm</button>
        </div>
      </div>
    </div>

    <!-- Completion Popup -->
    <div class="completion-overlay" id="completionOverlay">
      <button class="completion-close" onclick="closeCompletionPopup()">&times;</button>
      <div class="completion-icon">&#10003;</div>
      <div class="completion-title">Done!</div>
      <div class="completion-message" id="completionMessage"></div>
    </div>

    <!-- Reset Dialog -->
    <div class="reset-overlay" id="resetOverlay" onclick="closeResetDialog()">
      <div class="reset-dialog" onclick="event.stopPropagation()">
        <div class="reset-dialog-header">Reset Checklist</div>
        <div class="reset-dialog-body">
          <label class="reset-option" onclick="selectResetOption('unsealed')">
            <input type="radio" name="resetOption" value="unsealed">
            <div>
              <div class="reset-option-label">Reset unsealed areas only</div>
              <div class="reset-option-desc">Clears all item counts and restock decisions for areas that are not currently sealed.</div>
            </div>
          </label>
          <label class="reset-option" onclick="selectResetOption('all')">
            <input type="radio" name="resetOption" value="all">
            <div>
              <div class="reset-option-label">Reset everything</div>
              <div class="reset-option-desc">Breaks all seals and resets every item to zero. This cannot be undone.</div>
            </div>
          </label>
          <label class="reset-option" id="resetJotformOption" onclick="selectResetOption('jotform')" style="display:none">
            <input type="radio" name="resetOption" value="jotform">
            <div>
              <div class="reset-option-label">Restore from last submission</div>
              <div class="reset-option-desc">Fetches sealed area data from the most recent Jotform submission. Resets item counts but restores seals from the server.</div>
            </div>
          </label>
        </div>
        <div class="reset-dialog-footer">
          <button class="reset-cancel-btn" onclick="closeResetDialog()">Cancel</button>
          <button class="reset-confirm-btn" id="resetConfirmBtn" onclick="confirmReset()">Reset</button>
        </div>
        <div style="padding: 8px 20px 12px; border-top: 1px solid #eee; margin-top: 4px; text-align: center;">
          <a class="version-link" onclick="openChangelog()" id="versionDisplay"></a>
        </div>
      </div>
    </div>

    <!-- Changelog Dialog -->
    <div class="changelog-overlay" id="changelogOverlay" onclick="closeChangelog()">
      <div class="changelog-dialog" onclick="event.stopPropagation()">
        <div class="changelog-header">
          <span>Version History</span>
          <button class="changelog-close" onclick="closeChangelog()">&times;</button>
        </div>
        <div class="changelog-body" id="changelogBody"></div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jotfor.ms/s/umd/latest/for-custom-widgets.js"></script>
  <script>
    // =====================================================
    // INVENTORY DATA - Loaded from widget settings
    // =====================================================
    
    var INVENTORY = {};
    
    var DEFAULT_INVENTORY = "Area Name: Driver Compartment\nSealable: yes\nSafety Equipment\nFire Extinguisher|1\nReflective Vest|2\nTraffic Cones|3\nNavigation\nGPS Unit|1\nMap Book|1\n\nArea Name: Patient Compartment\nSealable: yes\nMonitoring\n>Cardiac\n>Cardiac Monitor|1\n>12-Lead ECG Cables|1\n>Defib Pads (Adult)|2\n>Respiratory\n>Pulse Oximeter|1\n>Capnography Tubing|2\nAirway Supplies\nBVM (Adult)|1\nBVM (Pediatric)|1\nOPA Set|1\nNPA Set|1\nKing Airway Kit|1\nET Tube Kit|1\nSuction Unit|1\nIV Supplies\nIV Start Kit|4\nNormal Saline 1000ml|2\nLactated Ringers|1\nIV Tubing|4\nMedications\nEpinephrine 1:10000|2\nAtropine|2\nAmiodarone|2\nNarcan|4\n\nArea Name: Upper CCT Cabinet\nSealable: yes\nCritical Care\nVentilator|1\nVent Circuit|2\nInfusion Pump|2\nPump Tubing|4\nPressure Bag|2\n\nArea Name: Bench Storage\n> Area Name: Left Bench\nSealable: yes\nBandaging\nGauze 4x4|20\nKerlix Rolls|6\nACE Wraps|4\nTriangular Bandage|4\nSplinting\nSAM Splint|2\nBoard Splint|2\nTraction Splint|1\n\n> Area Name: Right Bench\nSealable: yes\nCleaning\nHand Sanitizer|2\nDisinfectant Wipes|3\nBiohazard Bags|10\nLinens\nBlankets|4\nSheets|4\nPillowcase|4";
    
    // =====================================================
    // VERSION & CHANGELOG
    // =====================================================

    var VERSION = '1.5.6';
    var CHANGELOG = [
      { version: '1.5.6', date: '2026-02-23', changes: [
        'Uses JFCustomWidget.setFieldsValueById to write report to hidden field (cross-origin safe)',
      ]},
      { version: '1.5.5', date: '2026-02-23', changes: [
        'Switched back to direct parent DOM access for hidden field (testing with corrected API key)',
        'Report pushed on every state change and at submit time',
        'Comprehensive debug logging for field discovery',
      ]},
      { version: '1.5.4', date: '2026-02-23', changes: [
        'Fixed report writing to previous submission instead of current one',
        'Widget now captures last submission ID at init and polls for a new one after submit',
        'Polls up to 15 times (30s) until new submission appears before writing report',
      ]},
      { version: '1.5.3', date: '2026-02-23', changes: [
        'Report field ID now read from reportFieldID widget setting instead of hardcoded',
      ]},
      { version: '1.5.2', date: '2026-02-23', changes: [
        'Switched to Submissions API for writing report to field 38 (cross-origin prevents DOM access)',
        'Report written via API POST after form submission with 2s delay',
        'Added JFCustomWidget method discovery logging',
      ]},
      { version: '1.5.1', date: '2026-02-23', changes: [
        'Added debug logging for hidden field discovery',
        'Broadened hidden field selector patterns',
        'Hardcoded fallback to qid 38 for testing',
      ]},
      { version: '1.5.0', date: '2026-02-23', changes: [
        'Report now written to a separate hidden field (configured via reportFieldID widget setting)',
        'Widget submission value reverted to pure JSON sync data for cross-device restoration',
        'Report pushed to hidden field on every state change and at submit time',
      ]},
      { version: '1.4.3', date: '2026-02-23', changes: [
        'sendData now sends formatted report again (JotForm uses sendData value as final submission)',
        'Report uses <br> line breaks since JotForm strips plain newlines in submission display',
      ]},
      { version: '1.4.2', date: '2026-02-23', changes: [
        'Reverted sendData (draft saves) to raw JSON — fixes missing restocked items in submissions',
        'Only sendSubmit (final submission) generates the human-readable report',
        'Added "End of Report" marker before sync data block',
      ]},
      { version: '1.4.1', date: '2026-02-23', changes: [
        'Fixed sync data appearing in submissions (HTML comment delimiter was entity-encoded by JotForm)',
        'Sync data now uses plain-text ___SYNC_DATA___ delimiter that is visually separated from report',
        'extractSyncData now handles entity-encoded legacy formats for backward compatibility',
      ]},
      { version: '1.4.0', date: '2026-02-23', changes: [
        'Submission report is now plain text instead of HTML (JotForm entity-encodes HTML, making it unreadable)',
        'Report uses Unicode box-drawing characters and emoji section headers for readability',
      ]},
      { version: '1.3.1', date: '2026-02-23', changes: [
        'Fixed draft saves (sendData) sending raw JSON instead of formatted HTML report',
        'Submissions now always contain the human-readable report regardless of save path',
      ]},
      { version: '1.3.0', date: '2026-02-23', changes: [
        'Submission data is now a formatted HTML report instead of raw JSON',
        'Report groups restocked and unavailable items by area',
        'Added summary line with counts at top of report',
        'Color-coded section headers for quick scanning',
        'Sync data hidden in HTML comment to keep report clean',
      ]},
      { version: '1.2.1', date: '2026-02-23', changes: [
        'Fixed restock modal subcategory headers staying stuck when scrolling between categories',
      ]},
      { version: '1.2.0', date: '2026-02-22', changes: [
        'Added version changelog dialog (click version number to view)',
      ]},
      { version: '1.1.3', date: '2026-02-22', changes: [
        'Fixed sticky category/subcategory headers in restock modal (were not sticking due to measurement while modal hidden)',
        'Removed duplicate modal-body CSS rule',
      ]},
      { version: '1.1.2', date: '2026-02-22', changes: [
        'Fixed Mark All Restocked button falling behind sticky headers (z-index)',
        'Restored full text on Restocked and Out of Stock buttons',
      ]},
      { version: '1.1.1', date: '2026-02-22', changes: [
        'Clearer area separation in restock modal (dark headers)',
        'Quantity badge styled like checklist, placed left of item name',
        'Category headers sticky in restock modal',
      ]},
      { version: '1.1.0', date: '2026-02-22', changes: [
        'Redesigned restock modal with checklist-like hierarchy (area > category > subcategory)',
        'Parent/child area path shown in restock area headers',
        'Larger quantity needed badge',
      ]},
      { version: '1.0.4', date: '2026-02-22', changes: [
        'Fixed subcategory header gap in standalone areas (dynamic sticky offsets for all contexts)',
        'Removed hardcoded CSS top values for category headers',
      ]},
      { version: '1.0.3', date: '2026-02-22', changes: [
        'Fixed sticky header positioning for group child areas and subcategories (dynamic measurement)',
      ]},
      { version: '1.0.2', date: '2026-02-22', changes: [
        'Added "Restore from last submission" reset option',
        'Fixed formID caching from ready handler data',
      ]},
      { version: '1.0.1', date: '2026-02-22', changes: [
        'Fixed duplicate seal buttons for parent areas',
        'Fixed child seal button bottom padding',
      ]},
      { version: '1.0.0', date: '2026-02-22', changes: [
        'Initial release with full inventory checklist, sealing, restock workflow',
      ]},
    ];

    // =====================================================
    // STATE
    // =====================================================
    
    var itemStates = {}; // key -> { actual: number }
    var restockStatus = {}; // key -> { restocked: bool, outOfStock: bool, reason: string }
    var currentOutOfStockKey = null; // For dialog
    var selectedReason = null; // For dialog reason selection
    var taggedAreas = {}; // areaName -> { taggedDate: 'YYYY-MM-DD', taggedTimestamp: ms }
    var enableTaggedAreas = false;
    var sealReviewDay = 0; // Day of month (1-31) for mandatory expiration review, 0 = disabled
    var categoryMeta = {}; // "area::category" -> { level: 0|1, parent: null|string }
    var collapsedCategories = {}; // "area::category" -> true if collapsed
    var sealableAreas = {}; // areaName -> true if area can be sealed
    var areaHierarchy = {}; // parentAreaName -> [childAreaName, ...]
    var areaParent = {}; // childAreaName -> parentAreaName
    var brokenSeals = []; // [{ area, reason, taggedDate, brokenTimestamp }]
    var stateReady = false; // true after initial state load is complete
    var expandedArea = null; // currently expanded area name (standalone or child)
    var expandedGroup = null; // currently expanded parent group name
    var cachedFormID = null; // formID from JotForm ready event

    // =====================================================
    // LOCAL PERSISTENCE (survives across form sessions)
    // =====================================================

    function getStorageKey() {
      try {
        // Scope to the widget's iframe src for uniqueness across forms
        var src = window.location.href || '';
        if (src) {
          // Extract a stable identifier from the URL (formID, qid, etc.)
          var match = src.match(/[?&](?:formID|qid)=([^&]+)/);
          if (match) return 'ems_checklist_' + match[1];
        }
      } catch (e) {}
      return 'ems_checklist_state';
    }

    function saveState() {
      if (!stateReady) return;
      try {
        var state = {
          itemStates: itemStates,
          taggedAreas: taggedAreas,
          restockStatus: restockStatus,
          brokenSeals: brokenSeals,
          timestamp: Date.now()
        };
        localStorage.setItem(getStorageKey(), JSON.stringify(state));
      } catch (e) {
        // localStorage unavailable or quota exceeded
      }
      saveSealState();
      syncToJotForm();
    }

    var STATE_EXPIRY_MS = 8 * 60 * 60 * 1000; // 8 hours

    function loadState() {
      try {
        var stored = localStorage.getItem(getStorageKey());
        if (stored) {
          var parsed = JSON.parse(stored);
          // Expire stale state from abandoned sessions
          if (parsed.timestamp && (Date.now() - parsed.timestamp) > STATE_EXPIRY_MS) {
            localStorage.removeItem(getStorageKey());
            return null;
          }
          return parsed;
        }
      } catch (e) {}
      return null;
    }

    // Dedicated sealed-state persistence — survives across submissions and
    // is shared by every user on the same browser/device (e.g. shared tablet).
    function getSealStorageKey() {
      return getStorageKey() + '_seals';
    }

    function saveSealState() {
      if (!stateReady) return;
      try {
        var sealData = {
          taggedAreas: taggedAreas,
          brokenSeals: brokenSeals,
          timestamp: Date.now()
        };
        localStorage.setItem(getSealStorageKey(), JSON.stringify(sealData));
      } catch (e) {}
    }

    function loadSealState() {
      try {
        var stored = localStorage.getItem(getSealStorageKey());
        if (stored) return JSON.parse(stored);
      } catch (e) {}
      return null;
    }

    // Push current state to JotForm so it survives page refreshes and
    // draft-saves during the same form-filling session.
    function syncToJotForm() {
      if (typeof JFCustomWidget !== 'undefined' && JFCustomWidget.sendData) {
        try {
          var state = {
            itemStates: itemStates,
            taggedAreas: taggedAreas,
            restockStatus: restockStatus,
            brokenSeals: brokenSeals,
            timestamp: Date.now()
          };
          JFCustomWidget.sendData({ value: JSON.stringify(state) });
        } catch (e) {}
      }
      // Push the human-readable report to the hidden field
      pushReportToHiddenField();
    }

    // Push the human-readable report to a hidden field on the parent form
    // using JotForm's cross-origin bridge methods.
    function pushReportToHiddenField() {
      try {
        if (typeof JFCustomWidget === 'undefined') return;
        var reportFieldID = JFCustomWidget.getWidgetSetting('reportFieldID');
        if (!reportFieldID) {
          console.warn('[Widget] reportFieldID widget setting not found');
          return;
        }
        var submitData = generateSubmitValue();
        var report = submitData.report;
        var fid = String(reportFieldID);

        // Try setFieldsValueById with object format: {fieldId: value}
        try {
          var obj = {};
          obj[fid] = report;
          JFCustomWidget.setFieldsValueById(obj);
          console.log('[Widget] setFieldsValueById({' + fid + ': report}) called');
        } catch (e) {
          console.error('[Widget] setFieldsValueById obj format error:', e.message);
        }

        // Try storeToField with (id, value)
        try {
          JFCustomWidget.storeToField(fid, report);
          console.log('[Widget] storeToField(' + fid + ', report) called');
        } catch (e) {
          console.error('[Widget] storeToField error:', e.message);
        }
      } catch (e) {
        console.error('[Widget] pushReportToHiddenField error:', e.message);
      }
    }


    //  (a) pure JSON (old format / draft saves via syncToJotForm),
    //  (b) plain-text report with ___SYNC_DATA___ delimiter (current format), or
    //  (c) HTML with <!--__SYNC__:--> comment (legacy), or
    //  (d) plain text with __SYNC__ marker (transitional format).
    //  (c) HTML report with sync data in an HTML comment.
    // Returns the parsed data object, or null on failure.
    function extractSyncData(raw) {
      if (!raw || typeof raw !== 'string') return null;
      // Try pure JSON first (old format / draft saves)
      try { return JSON.parse(raw); } catch (e) {}
      // Current format: plain-text delimiter (immune to entity encoding)
      var syncMarker = '\n\n___SYNC_DATA___\n';
      var si = raw.indexOf(syncMarker);
      if (si !== -1) {
        try { return JSON.parse(raw.substring(si + syncMarker.length)); } catch (e) {}
      }
      // Legacy: HTML comment format (may appear raw or entity-encoded)
      var commentVariants = ['<!--__SYNC__:', '&lt;!--__SYNC__:'];
      var endVariants = ['-->', '--&gt;'];
      for (var v = 0; v < commentVariants.length; v++) {
        var ci = raw.indexOf(commentVariants[v]);
        if (ci !== -1) {
          for (var ev = 0; ev < endVariants.length; ev++) {
            var ce = raw.indexOf(endVariants[ev], ci);
            if (ce !== -1) {
              try { return JSON.parse(raw.substring(ci + commentVariants[v].length, ce)); } catch (e) {}
            }
          }
        }
      }
      // Legacy: plain text marker (transitional)
      var marker = '\n__SYNC__\n';
      var idx = raw.indexOf(marker);
      if (idx !== -1) {
        try { return JSON.parse(raw.substring(idx + marker.length)); } catch (e) {}
      }
      return null;
    }

    // =====================================================
    // CROSS-DEVICE PERSISTENCE (JotForm Submissions API)
    // =====================================================

    // Extract formID and qid from the widget iframe URL.
    function getFormParams() {
      var params = { formID: null, qid: null };
      try {
        var src = window.location.href || '';
        var fMatch = src.match(/[?&]formID=([^&]+)/);
        var qMatch = src.match(/[?&]qid=([^&]+)/);
        if (fMatch) params.formID = fMatch[1];
        if (qMatch) params.qid = qMatch[1];
      } catch (e) {}
      return params;
    }

    // Fetch the sealed state from the most recent JotForm submission so that
    // seals persist across devices and browsers.  Requires the form admin to
    // add a "jotformApiKey" widget setting (read-only API key is sufficient).
    function fetchLatestSealState(apiBase, formID, apiKey, qid, callback) {
      if (!formID || !apiKey) { callback(null); return; }
      var url = apiBase + '/form/' + encodeURIComponent(formID)
              + '/submissions?apiKey=' + encodeURIComponent(apiKey)
              + '&limit=1&orderby=id&direction=desc';
      try {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.timeout = 5000;
        xhr.onload = function () {
          if (xhr.status !== 200) { callback(null); return; }
          try {
            var resp = JSON.parse(xhr.responseText);
            if (!resp.content || resp.content.length === 0) { callback(null); return; }
            var answers = resp.content[0].answers || {};
            var raw = null;

            // Prefer the exact question id when available.
            if (qid && answers[qid]) {
              raw = answers[qid].answer;
            }
            // Fallback: scan every answer for one that looks like our widget value.
            if (!raw) {
              for (var k in answers) {
                var a = answers[k].answer;
                if (typeof a === 'string' && a.indexOf('taggedAreas') !== -1) {
                  raw = a; break;
                }
              }
            }
            if (!raw) { callback(null); return; }

            var parsed = extractSyncData(raw);
            if (!parsed) { callback(null); return; }

            // Jotform may HTML-entity-encode submission values (e.g. -> becomes -&gt;).
            // Decode so that keys match the original inventory area names.
            var decodeEntities = function(str) {
              var txt = document.createElement('textarea');
              txt.innerHTML = str;
              return txt.value;
            };
            var decodeParsedKeys = function(obj) {
              if (!obj || typeof obj !== 'object') return obj;
              var decoded = {};
              for (var k in obj) {
                decoded[decodeEntities(k)] = obj[k];
              }
              return decoded;
            };
            if (parsed.taggedAreas) parsed.taggedAreas = decodeParsedKeys(parsed.taggedAreas);
            if (parsed.itemStates) parsed.itemStates = decodeParsedKeys(parsed.itemStates);
            if (parsed.restockStatus) parsed.restockStatus = decodeParsedKeys(parsed.restockStatus);

            var taggedKeys = parsed.taggedAreas ? Object.keys(parsed.taggedAreas) : [];
            if (parsed && parsed.taggedAreas && taggedKeys.length > 0) {
              callback({
                taggedAreas: parsed.taggedAreas,
                brokenSeals: parsed.brokenSeals || [],
                timestamp: parsed.timestamp || 0
              });
              return;
            }
          } catch (e) {}
          callback(null);
        };
        xhr.onerror = function () { callback(null); };
        xhr.ontimeout = function () { callback(null); };
        xhr.send();
      } catch (e) { callback(null); }
    }

    // =====================================================
    // PARSE INVENTORY FROM SETTINGS
    // =====================================================

    function parseInventory(text) {
      var lines = text.split("\n");
      var result = {};
      var currentArea = "Items";
      var currentCategory = "General";
      var currentTopCategory = "General";
      var lastTopLevelArea = null; // Most recent non-nested Area Name
      categoryMeta = {};
      sealableAreas = {};
      areaHierarchy = {};
      areaParent = {};

      for (var i = 0; i < lines.length; i++) {
        var line = lines[i].trim();
        if (!line) continue;

        // Check for nested area: "> Area Name: X" — child of most recent top-level area
        var nestedAreaMatch = line.match(/^>\s*Area Name:\s*(.+)/i);
        if (nestedAreaMatch) {
          currentArea = nestedAreaMatch[1].trim();
          currentCategory = "General";
          currentTopCategory = "General";
          if (!result[currentArea]) {
            result[currentArea] = {};
          }
          // Register as child of most recent top-level area
          if (lastTopLevelArea) {
            if (!areaHierarchy[lastTopLevelArea]) {
              areaHierarchy[lastTopLevelArea] = [];
            }
            areaHierarchy[lastTopLevelArea].push(currentArea);
            areaParent[currentArea] = lastTopLevelArea;
          }
          continue;
        }

        // Check if it's a top-level area (starts with "Area Name:")
        if (line.toLowerCase().indexOf('area name:') === 0) {
          currentArea = line.substring(10).trim();
          currentCategory = "General";
          currentTopCategory = "General";
          lastTopLevelArea = currentArea;
          if (!result[currentArea]) {
            result[currentArea] = {};
          }
          continue;
        }

        // Check if it marks the current area as sealable
        if (line.toLowerCase().indexOf('sealable:') === 0) {
          var val = line.substring(9).trim().toLowerCase();
          if (val === 'yes' || val === 'true') {
            sealableAreas[currentArea] = true;
          }
          continue;
        }

        // Check if it's an item (contains |)
        if (line.indexOf('|') !== -1) {
          var isSubItem = line.charAt(0) === '>';
          var itemLine = isSubItem ? line.substring(1).trim() : line;
          var parts = itemLine.split('|');
          var itemName = parts[0].trim();
          var qty = parseInt(parts[1], 10) || 1;

          // If item doesn't have > prefix and we're in a subcategory, revert to parent
          if (!isSubItem) {
            var curMeta = categoryMeta[currentArea + '::' + currentCategory];
            if (curMeta && curMeta.level === 1) {
              currentCategory = currentTopCategory;
            }
          }

          if (!result[currentArea]) {
            result[currentArea] = {};
          }
          if (!result[currentArea][currentCategory]) {
            result[currentArea][currentCategory] = [];
          }

          result[currentArea][currentCategory].push({
            name: itemName,
            required: qty
          });
        } else if (line.charAt(0) === '>') {
          // Subcategory (line starts with >)
          var subCatName = line.substring(1).trim();
          var qualifiedName = currentTopCategory + ' > ' + subCatName;
          currentCategory = qualifiedName;
          if (!result[currentArea]) {
            result[currentArea] = {};
          }
          if (!result[currentArea][qualifiedName]) {
            result[currentArea][qualifiedName] = [];
          }
          categoryMeta[currentArea + '::' + qualifiedName] = { level: 1, parent: currentTopCategory, displayName: subCatName };
        } else {
          // Top-level category name
          currentCategory = line;
          currentTopCategory = line;
          if (!result[currentArea]) {
            result[currentArea] = {};
          }
          if (!result[currentArea][line]) {
            result[currentArea][line] = [];
          }
          categoryMeta[currentArea + '::' + line] = { level: 0, parent: null };
        }
      }

      return result;
    }
    
    // =====================================================
    // BUILD UI
    // =====================================================
    
    function generateKey(areaName, categoryName, itemName) {
      return areaName + '::' + categoryName + '::' + itemName;
    }

    function buildItemRow(areaName, catName, item) {
      var key = generateKey(areaName, catName, item.name);

      if (!itemStates[key]) {
        itemStates[key] = { actual: 0 };
      }

      var itemDiv = document.createElement('div');
      itemDiv.className = 'checklist-item';
      itemDiv.id = 'item_' + key.replace(/[^a-zA-Z0-9]/g, '_');

      var actual = itemStates[key].actual;
      var status = restockStatus[key] || {};
      var isRestocked = status.restocked && actual < item.required;
      var isOutOfStock = status.outOfStock && actual < item.required;

      var checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'item-checkbox';
      checkbox.checked = actual >= item.required || isRestocked || isOutOfStock;
      checkbox.onchange = (function(k, req) {
        return function() { setItemValue(k, this.checked ? req : 0); };
      })(key, item.required);

      var infoDiv = document.createElement('div');
      infoDiv.className = 'item-info';
      infoDiv.innerHTML = '<div class="item-name">' + escapeHtml(item.name) + '</div>';

      var reqLabel = document.createElement('span');
      reqLabel.className = 'item-required';
      reqLabel.textContent = '×' + item.required;

      itemDiv.appendChild(checkbox);
      itemDiv.appendChild(infoDiv);
      itemDiv.appendChild(reqLabel);

      if (isRestocked) {
        // Show restocked tag instead of stepper
        var shortage = item.required - actual;
        var restockedTag = document.createElement('div');
        restockedTag.className = 'restocked-tag';
        restockedTag.innerHTML = '<span>Restocked</span><span class="restocked-qty">(×' + shortage + ')</span>';
        
        var removeBtn = document.createElement('button');
        removeBtn.className = 'restocked-remove';
        removeBtn.innerHTML = '×';
        removeBtn.onclick = (function(k) {
          return function(e) {
            e.stopPropagation();
            removeRestockedFromChecklist(k);
          };
        })(key);
        restockedTag.appendChild(removeBtn);
        
        itemDiv.appendChild(restockedTag);
        itemDiv.classList.add('restocked');
      } else if (isOutOfStock) {
        // Show out-of-stock tag instead of stepper
        var shortage = item.required - actual;
        var outOfStockTag = document.createElement('div');
        outOfStockTag.className = 'out-of-stock-tag';
        outOfStockTag.innerHTML = '<span>Out of Stock</span><span class="restocked-qty">(×' + shortage + ')</span>';
        
        var removeBtn = document.createElement('button');
        removeBtn.className = 'out-of-stock-remove';
        removeBtn.innerHTML = '×';
        removeBtn.onclick = (function(k) {
          return function(e) {
            e.stopPropagation();
            removeRestockedFromChecklist(k);
          };
        })(key);
        outOfStockTag.appendChild(removeBtn);
        
        itemDiv.appendChild(outOfStockTag);
        itemDiv.classList.add('out-of-stock-item');
      } else {
        // Show normal stepper
        var stepperDiv = document.createElement('div');
        stepperDiv.className = 'qty-stepper';

        var decBtn = document.createElement('button');
        decBtn.className = 'qty-btn';
        decBtn.textContent = '-';
        decBtn.onclick = (function(k) {
          return function() { adjustItem(k, -1); };
        })(key);

        var valueInput = document.createElement('input');
        valueInput.type = 'number';
        valueInput.className = 'qty-value';
        valueInput.value = actual;
        valueInput.min = '0';
        valueInput.max = item.required;
        valueInput.id = 'input_' + key.replace(/[^a-zA-Z0-9]/g, '_');
        valueInput.onchange = (function(k) {
          return function() { setItemValue(k, parseInt(this.value) || 0); };
        })(key);

        var incBtn = document.createElement('button');
        incBtn.className = 'qty-btn';
        incBtn.textContent = '+';
        incBtn.onclick = (function(k) {
          return function() { adjustItem(k, 1); };
        })(key);

        stepperDiv.appendChild(decBtn);
        stepperDiv.appendChild(valueInput);
        stepperDiv.appendChild(incBtn);
        itemDiv.appendChild(stepperDiv);

        // Apply appropriate class based on state
        if (actual >= item.required) {
          itemDiv.classList.add('checked');
        } else if (actual > 0) {
          itemDiv.classList.add('short');
        } else {
          itemDiv.classList.add('missing');
        }
      }

      return itemDiv;
    }

    // Remove restocked designation from checklist
    function removeRestockedFromChecklist(key) {
      delete restockStatus[key];
      updateAllStatuses();
      updateSummary();
      // Rebuild the affected item row
      var parts = key.split('::');
      var areaName = parts[0];
      var catName = parts[1];
      var itemName = parts[2];
      var item = findItem(areaName, catName, itemName);
      if (item) {
        var itemDiv = document.getElementById('item_' + key.replace(/[^a-zA-Z0-9]/g, '_'));
        if (itemDiv) {
          var newRow = buildItemRow(areaName, catName, item);
          itemDiv.parentNode.replaceChild(newRow, itemDiv);
        }
      }
    }

    function buildUI() {
      var container = document.getElementById('areasContainer');
      container.innerHTML = '';

      // Determine rendering order: parent groups first (with children inside),
      // then standalone areas (not a child of any parent).
      var rendered = {}; // track which areas have been rendered

      // Helper: build a single area section (used for both standalone and child areas)
      function buildAreaSection(areaName) {
        var areaDiv = document.createElement('div');
        areaDiv.className = 'area-section';
        areaDiv.id = 'area_' + areaName.replace(/[^a-zA-Z0-9]/g, '_');

        // Area header
        var headerDiv = document.createElement('div');
        headerDiv.className = 'area-header';
        headerDiv.innerHTML = '<span class="collapse-icon">▶</span>' +
          '<span class="area-title">' + escapeHtml(areaName) + '</span>' +
          '<span class="area-status" id="status_' + areaDiv.id + '">0/0</span>';

        headerDiv.onclick = (function(div, isChild) {
          return function() { toggleArea(div, isChild); };
        })(areaDiv, !!areaParent[areaName]);

        areaDiv.appendChild(headerDiv);

        // Area content
        var contentDiv = document.createElement('div');
        contentDiv.className = 'area-content';

        if (taggedAreas[areaName]) {
          // Render tagged/sealed panel instead of items
          var tagInfo = taggedAreas[areaName];
          var daysSince = daysSinceTagged(tagInfo.taggedTimestamp);
          var reviewNeeded = isReviewOverdue(tagInfo.taggedTimestamp);

          var panel = document.createElement('div');
          panel.className = 'tagged-panel' + (reviewNeeded ? ' review-needed' : '');

          var panelHtml = '';
          if (reviewNeeded) {
            panelHtml += '<div class="seal-icon">&#9888;</div>';
            panelHtml += '<div class="seal-title">EXPIRATION REVIEW NEEDED</div>';
          } else {
            panelHtml += '<div class="seal-icon">&#x1F512;</div>';
            panelHtml += '<div class="seal-title">AREA SEALED</div>';
          }

          panelHtml += '<div class="seal-date">Tagged: ' + formatTagDate(tagInfo.taggedDate) + '</div>';
          panelHtml += '<div class="seal-days">Sealed for ' + daysSince + ' day' + (daysSince !== 1 ? 's' : '') + '</div>';

          if (reviewNeeded) {
            panelHtml += '<div class="seal-expired-warning">Monthly review was due on the ' + sealReviewDay + getOrdinalSuffix(sealReviewDay) + '. Break seal to review expiration dates of contents.</div>';
          } else if (sealReviewDay > 0) {
            var nextReview = getNextReviewDate();
            if (nextReview) {
              panelHtml += '<div class="seal-warning">Next expiration review: ' + formatTagDate(nextReview.toISOString().split('T')[0]) + '</div>';
            }
          }

          var escapedName = escapeHtml(areaName).replace(/'/g, "\\'");
          panelHtml += '<div class="seal-actions">';
          panelHtml += '<button class="break-seal-btn" onclick="breakSeal(\'' + escapedName + '\', \'review\')">Break Seal &amp; Review</button>';
          panelHtml += '<button class="seal-missing-btn" onclick="breakSeal(\'' + escapedName + '\', \'missing\')">Seal is Missing</button>';
          panelHtml += '</div>';

          panel.innerHTML = panelHtml;
          contentDiv.appendChild(panel);

          // Still initialize itemStates keys for tagged areas
          var categories = INVENTORY[areaName];
          for (var catName in categories) {
            var items = categories[catName];
            for (var i = 0; i < items.length; i++) {
              var key = generateKey(areaName, catName, items[i].name);
              if (!itemStates[key]) {
                itemStates[key] = { actual: items[i].required };
              }
            }
          }
        } else {
          // Normal rendering: collapsible categories with optional subcategories
          var categories = INVENTORY[areaName];

          // Group categories into top-level and subcategories
          var catOrder = [];
          var catChildren = {};
          for (var catName in categories) {
            var metaKey = areaName + '::' + catName;
            var meta = categoryMeta[metaKey] || { level: 0, parent: null };
            if (meta.level === 0) {
              catOrder.push(catName);
              if (!catChildren[catName]) catChildren[catName] = [];
            } else if (meta.parent) {
              if (!catChildren[meta.parent]) catChildren[meta.parent] = [];
              catChildren[meta.parent].push(catName);
            }
          }

          for (var ci = 0; ci < catOrder.length; ci++) {
            var catName = catOrder[ci];
            var catItems = categories[catName] || [];
            var subCats = catChildren[catName] || [];
            var catKey = areaName + '::' + catName;
            var isCollapsed = collapsedCategories[catKey] || false;

            // Category header (collapsible)
            var catHeader = document.createElement('div');
            catHeader.className = 'category-header';
            catHeader.onclick = (function(area, cat) {
              return function(e) {
                if (e.target.classList.contains('category-checkbox')) return;
                toggleCategoryCollapse(area, cat);
              };
            })(areaName, catName);

            var collapseIcon = document.createElement('span');
            collapseIcon.className = 'category-collapse-icon';
            collapseIcon.id = 'cat_icon_' + catKey.replace(/[^a-zA-Z0-9]/g, '_');
            collapseIcon.textContent = '\u25B6';
            collapseIcon.style.transform = isCollapsed ? 'rotate(0deg)' : 'rotate(90deg)';

            var catCheckbox = document.createElement('input');
            catCheckbox.type = 'checkbox';
            catCheckbox.className = 'category-checkbox';
            catCheckbox.onclick = (function(area, cat, subs) {
              return function(e) {
                e.stopPropagation();
                var isChecked = this.checked;
                // Batch: set all items for parent category + subcategories
                var allCats = [cat].concat(subs);
                for (var c = 0; c < allCats.length; c++) {
                  var catItems = INVENTORY[area][allCats[c]];
                  if (!catItems) continue;
                  for (var i = 0; i < catItems.length; i++) {
                    var key = generateKey(area, allCats[c], catItems[i].name);
                    setItemValue(key, isChecked ? catItems[i].required : 0, true);
                  }
                }

                // Explicitly sync all subcategory checkboxes
                for (var s = 0; s < subs.length; s++) {
                  var subStatusId = 'cat_status_' + generateKey(area, subs[s], '').replace(/[^a-zA-Z0-9]/g, '_');
                  var subStatusEl = document.getElementById(subStatusId);
                  if (subStatusEl && subStatusEl.parentElement) {
                    var subCb = subStatusEl.parentElement.querySelector('.category-checkbox');
                    if (subCb) subCb.checked = isChecked;
                  }
                }

                updateAllStatuses();
                updateSummary();

                if (isChecked) {
                  autoCategoryAdvance(area, cat);
                  checkForCompletion();
                } else {
                  // Reopen so user can see unchecked items
                  var catKey = area + '::' + cat;
                  collapsedCategories[catKey] = false;
                  var itemsDiv = document.getElementById('cat_items_' + catKey.replace(/[^a-zA-Z0-9]/g, '_'));
                  if (itemsDiv) itemsDiv.style.display = 'block';
                  var icon = document.getElementById('cat_icon_' + catKey.replace(/[^a-zA-Z0-9]/g, '_'));
                  if (icon) icon.style.transform = 'rotate(90deg)';
                }
              };
            })(areaName, catName, subCats);

            var catLabel = document.createElement('span');
            catLabel.textContent = catName;

            var catStatus = document.createElement('span');
            catStatus.className = 'category-status';
            catStatus.id = 'cat_status_' + generateKey(areaName, catName, '').replace(/[^a-zA-Z0-9]/g, '_');

            catHeader.appendChild(collapseIcon);
            catHeader.appendChild(catCheckbox);
            catHeader.appendChild(catLabel);
            catHeader.appendChild(catStatus);
            contentDiv.appendChild(catHeader);

            // Items container (collapsible)
            var itemsContainer = document.createElement('div');
            itemsContainer.className = 'category-items';
            itemsContainer.id = 'cat_items_' + catKey.replace(/[^a-zA-Z0-9]/g, '_');
            itemsContainer.style.display = isCollapsed ? 'none' : 'block';

            // Direct items for this category
            for (var i = 0; i < catItems.length; i++) {
              itemsContainer.appendChild(buildItemRow(areaName, catName, catItems[i]));
            }

            // Subcategories - append directly to contentDiv for sticky positioning to work
            for (var si = 0; si < subCats.length; si++) {
              var subCatName = subCats[si];
              var subCatItems = categories[subCatName] || [];
              var subCatKey = areaName + '::' + subCatName;
              var isSubCollapsed = collapsedCategories[subCatKey] || false;

              // Subcategory header
              var subHeader = document.createElement('div');
              subHeader.className = 'subcategory-header';
              subHeader.onclick = (function(area, sub) {
                return function(e) {
                  if (e.target.classList.contains('category-checkbox')) return;
                  toggleCategoryCollapse(area, sub);
                };
              })(areaName, subCatName);

              var subIcon = document.createElement('span');
              subIcon.className = 'category-collapse-icon';
              subIcon.id = 'cat_icon_' + subCatKey.replace(/[^a-zA-Z0-9]/g, '_');
              subIcon.textContent = '\u25B6';
              subIcon.style.transform = isSubCollapsed ? 'rotate(0deg)' : 'rotate(90deg)';

              var subCheckbox = document.createElement('input');
              subCheckbox.type = 'checkbox';
              subCheckbox.className = 'category-checkbox';
              subCheckbox.onclick = (function(area, sub) {
                return function(e) {
                  e.stopPropagation();
                  toggleCategory(area, sub, this.checked);
                };
              })(areaName, subCatName);

              var subLabel = document.createElement('span');
              var subDisplayMeta = categoryMeta[areaName + '::' + subCatName];
              subLabel.textContent = (subDisplayMeta && subDisplayMeta.displayName) || subCatName;

              var subStatus = document.createElement('span');
              subStatus.className = 'category-status';
              subStatus.id = 'cat_status_' + generateKey(areaName, subCatName, '').replace(/[^a-zA-Z0-9]/g, '_');

              subHeader.appendChild(subIcon);
              subHeader.appendChild(subCheckbox);
              subHeader.appendChild(subLabel);
              subHeader.appendChild(subStatus);
              itemsContainer.appendChild(subHeader);

              // Subcategory items container
              var subItemsContainer = document.createElement('div');
              subItemsContainer.className = 'subcategory-items';
              subItemsContainer.id = 'cat_items_' + subCatKey.replace(/[^a-zA-Z0-9]/g, '_');
              subItemsContainer.style.display = isSubCollapsed ? 'none' : 'block';

              for (var j = 0; j < subCatItems.length; j++) {
                subItemsContainer.appendChild(buildItemRow(areaName, subCatName, subCatItems[j]));
              }
              itemsContainer.appendChild(subItemsContainer);
            }

            contentDiv.appendChild(itemsContainer);
          }

          // Add "Seal This Area" button if this area is marked sealable
          // Skip for parent areas with children — they get a seal button in buildParentGroup instead
          if (sealableAreas[areaName] && !areaHierarchy[areaName]) {
            var tagBtn = document.createElement('button');
            tagBtn.className = 'tag-area-btn';
            tagBtn.id = 'tag_btn_' + areaName.replace(/[^a-zA-Z0-9]/g, '_');
            tagBtn.textContent = 'Seal This Area';
            tagBtn.onclick = (function(name) {
              return function(e) {
                e.stopPropagation();
                tagArea(name);
              };
            })(areaName);
            contentDiv.appendChild(tagBtn);
          }
        }

        areaDiv.appendChild(contentDiv);
        return areaDiv;
      }

      // Build a parent area group containing its child areas
      function buildParentGroup(parentName, children) {
        var groupDiv = document.createElement('div');
        groupDiv.className = 'area-group';
        groupDiv.id = 'area_group_' + parentName.replace(/[^a-zA-Z0-9]/g, '_');

        // Parent header
        var headerDiv = document.createElement('div');
        headerDiv.className = 'area-header';
        headerDiv.innerHTML = '<span class="collapse-icon">▶</span>' +
          '<span class="area-title">' + escapeHtml(parentName) + '</span>' +
          '<span class="area-status" id="status_group_' + parentName.replace(/[^a-zA-Z0-9]/g, '_') + '">0/0</span>';

        headerDiv.onclick = (function(div) {
          return function() { toggleAreaGroup(div); };
        })(groupDiv);

        groupDiv.appendChild(headerDiv);

        // Content
        var contentDiv = document.createElement('div');
        contentDiv.className = 'area-group-content';

        if (taggedAreas[parentName]) {
          // Parent is sealed — show sealed panel for parent, but still show child areas
          var tagInfo = taggedAreas[parentName];
          var daysSince = daysSinceTagged(tagInfo.taggedTimestamp);
          var reviewNeeded = isReviewOverdue(tagInfo.taggedTimestamp);

          var panel = document.createElement('div');
          panel.className = 'tagged-panel' + (reviewNeeded ? ' review-needed' : '');

          var panelHtml = '';
          if (reviewNeeded) {
            panelHtml += '<div class="seal-icon">&#9888;</div>';
            panelHtml += '<div class="seal-title">EXPIRATION REVIEW NEEDED</div>';
          } else {
            panelHtml += '<div class="seal-icon">&#x1F512;</div>';
            panelHtml += '<div class="seal-title">AREA SEALED</div>';
          }

          panelHtml += '<div class="seal-date">Tagged: ' + formatTagDate(tagInfo.taggedDate) + '</div>';
          panelHtml += '<div class="seal-days">Sealed for ' + daysSince + ' day' + (daysSince !== 1 ? 's' : '') + '</div>';

          if (reviewNeeded) {
            panelHtml += '<div class="seal-expired-warning">Monthly review was due on the ' + sealReviewDay + getOrdinalSuffix(sealReviewDay) + '. Break seal to review expiration dates of contents.</div>';
          } else if (sealReviewDay > 0) {
            var nextReview = getNextReviewDate();
            if (nextReview) {
              panelHtml += '<div class="seal-warning">Next expiration review: ' + formatTagDate(nextReview.toISOString().split('T')[0]) + '</div>';
            }
          }

          var escapedParent = escapeHtml(parentName).replace(/'/g, "\\'");
          panelHtml += '<div class="seal-actions">';
          panelHtml += '<button class="break-seal-btn" onclick="breakSeal(\'' + escapedParent + '\', \'review\')">Break Seal &amp; Review</button>';
          panelHtml += '<button class="seal-missing-btn" onclick="breakSeal(\'' + escapedParent + '\', \'missing\')">Seal is Missing</button>';
          panelHtml += '</div>';

          panel.innerHTML = panelHtml;
          contentDiv.appendChild(panel);

          // Initialize parent item states for sealed parent
          if (INVENTORY[parentName]) {
            for (var catName in INVENTORY[parentName]) {
              var items = INVENTORY[parentName][catName];
              for (var i = 0; i < items.length; i++) {
                var key = generateKey(parentName, catName, items[i].name);
                if (!itemStates[key]) {
                  itemStates[key] = { actual: items[i].required };
                }
              }
            }
          }
        } else {
          // Parent not sealed — render parent's own items if any
          if (INVENTORY[parentName]) {
            var parentSection = buildAreaSection(parentName);
            // Unwrap: insert the area-content children directly so items appear
            // inline within the group rather than as a nested collapsible
            var parentContent = parentSection.querySelector('.area-content');
            if (parentContent) {
              var wrapper = document.createElement('div');
              wrapper.className = 'parent-own-items';
              while (parentContent.firstChild) {
                wrapper.appendChild(parentContent.firstChild);
              }
              contentDiv.appendChild(wrapper);
            }
            rendered[parentName] = true;
          }
        }

        // Always render child areas (whether parent is sealed or not)
        for (var c = 0; c < children.length; c++) {
          var childName = children[c];
          if (INVENTORY[childName]) {
            contentDiv.appendChild(buildAreaSection(childName));
            rendered[childName] = true;
          }
        }

        // Parent seal button — only if parent is sealable and not already sealed
        if (sealableAreas[parentName] && !taggedAreas[parentName]) {
          var tagBtn = document.createElement('button');
          tagBtn.className = 'tag-area-btn';
          tagBtn.id = 'tag_btn_group_' + parentName.replace(/[^a-zA-Z0-9]/g, '_');
          tagBtn.textContent = 'Seal ' + parentName;
          tagBtn.onclick = (function(name) {
            return function(e) {
              e.stopPropagation();
              tagArea(name);
            };
          })(parentName);
          contentDiv.appendChild(tagBtn);
        }

        groupDiv.appendChild(contentDiv);
        return groupDiv;
      }

      // Render parent groups first (in order they appeared in config)
      // We need to preserve insertion order, so iterate areaHierarchy keys
      // which were added in parse order.
      for (var parentName in areaHierarchy) {
        var children = areaHierarchy[parentName];
        if (children.length > 0) {
          container.appendChild(buildParentGroup(parentName, children));
          rendered[parentName] = true;
          for (var ci = 0; ci < children.length; ci++) {
            rendered[children[ci]] = true;
          }
        }
      }

      // Render standalone areas (not part of any group)
      for (var areaName in INVENTORY) {
        if (rendered[areaName]) continue;
        container.appendChild(buildAreaSection(areaName));
      }

      updateAllStatuses();
      updateSummary();

      // Restore expanded state after DOM rebuild
      if (expandedGroup) {
        var groupDiv = document.getElementById('area_group_' + expandedGroup.replace(/[^a-zA-Z0-9]/g, '_'));
        if (groupDiv) {
          if (isGroupComplete(expandedGroup)) {
            expandedGroup = null;
            expandedArea = null;
          } else {
            groupDiv.classList.add('expanded');

            if (expandedArea) {
              var childDiv = document.getElementById('area_' + expandedArea.replace(/[^a-zA-Z0-9]/g, '_'));
              if (childDiv && groupDiv.contains(childDiv)) {
                if (taggedAreas[expandedArea] || (INVENTORY[expandedArea] && isAreaAllOk(expandedArea))) {
                  // Current child is done — advance to next incomplete child
                  var children = areaHierarchy[expandedGroup] || [];
                  var nextChild = null;
                  for (var nc = 0; nc < children.length; nc++) {
                    if (!taggedAreas[children[nc]] && INVENTORY[children[nc]] && !isAreaAllOk(children[nc])) {
                      nextChild = children[nc]; break;
                    }
                  }
                  if (nextChild) {
                    expandedArea = nextChild;
                    var nextDiv = document.getElementById('area_' + nextChild.replace(/[^a-zA-Z0-9]/g, '_'));
                    if (nextDiv) nextDiv.classList.add('expanded');
                  } else {
                    expandedArea = null;
                  }
                } else {
                  childDiv.classList.add('expanded');
                }
              }
            }
          }
        }
      } else if (expandedArea) {
        var areaDiv = document.getElementById('area_' + expandedArea.replace(/[^a-zA-Z0-9]/g, '_'));
        if (areaDiv) {
          // Keep open if area still has work to do (items unchecked, or sealable but not yet sealed)
          var stillHasWork = !taggedAreas[expandedArea] && (!isAreaAllOk(expandedArea) || (sealableAreas[expandedArea] && isAreaSealable(expandedArea)));
          if (stillHasWork) {
            areaDiv.classList.add('expanded');
          } else {
            expandedArea = null;
          }
        }
      }

      updateStickyOffsets();
    }

    // Check if a parent group is fully complete (all children sealed/ok, parent items ok/sealed)
    function isGroupComplete(groupName) {
      // Parent sealed means everything is done
      if (taggedAreas[groupName]) return true;

      var children = areaHierarchy[groupName] || [];
      for (var i = 0; i < children.length; i++) {
        if (!INVENTORY[children[i]]) continue;
        if (!taggedAreas[children[i]] && !isAreaAllOk(children[i])) return false;
      }
      // Check parent's own items
      if (INVENTORY[groupName] && !isAreaAllOk(groupName)) return false;
      // If sealable and everything is ready to seal but not sealed yet, not complete
      if (sealableAreas[groupName] && isAreaSealable(groupName)) return false;
      return true;
    }
    
    // Dynamically measure sticky header heights and set subcategory top values.
    // Called after any area is expanded so the DOM is ready for measurement.
    function updateStickyOffsets() {
      // Find all expanded area-sections and set sticky tops
      var expandedSections = document.querySelectorAll('.area-section.expanded');
      for (var i = 0; i < expandedSections.length; i++) {
        var section = expandedSections[i];
        var areaHeader = section.querySelector(':scope > .area-header');
        var categoryHeaders = section.querySelectorAll('.category-header');
        var subcategoryHeaders = section.querySelectorAll('.subcategory-header');

        if (!areaHeader) continue;

        // Measure the area header height
        var areaH = areaHeader.getBoundingClientRect().height;

        // Check if this section is inside a group (has a parent group header too)
        var groupDiv = section.closest('.area-group.expanded');
        var groupHeaderH = 0;
        if (groupDiv) {
          var groupHeader = groupDiv.querySelector(':scope > .area-header');
          if (groupHeader) groupHeaderH = groupHeader.getBoundingClientRect().height;
          // Set child area header top to sit below group header
          areaHeader.style.top = groupHeaderH + 'px';
        }

        // Set category header tops for ALL contexts (standalone and group)
        if (categoryHeaders.length > 0) {
          var catTop = groupHeaderH + areaH;
          for (var c = 0; c < categoryHeaders.length; c++) {
            categoryHeaders[c].style.top = catTop + 'px';
          }
        }

        // Measure a category header height (they're all the same size)
        var catH = 0;
        if (categoryHeaders.length > 0) {
          catH = categoryHeaders[0].getBoundingClientRect().height;
        }

        // Set subcategory header tops
        if (subcategoryHeaders.length > 0) {
          var subTop = groupHeaderH + areaH + catH;
          // For standalone areas (no group), areaH is the only prefix
          if (!groupDiv) subTop = areaH + catH;

          for (var j = 0; j < subcategoryHeaders.length; j++) {
            subcategoryHeaders[j].style.top = subTop + 'px';
          }
        }
      }

      // Also handle parent-own-items (no child area-header, just group header)
      var parentOwnItems = document.querySelectorAll('.area-group.expanded .parent-own-items');
      for (var i = 0; i < parentOwnItems.length; i++) {
        var wrapper = parentOwnItems[i];
        var groupDiv = wrapper.closest('.area-group.expanded');
        if (!groupDiv) continue;

        var groupHeader = groupDiv.querySelector(':scope > .area-header');
        var groupHeaderH = groupHeader ? groupHeader.getBoundingClientRect().height : 0;

        var catHeaders = wrapper.querySelectorAll('.category-header');
        var subHeaders = wrapper.querySelectorAll('.subcategory-header');

        // Category headers in parent-own-items sit below just the group header
        if (catHeaders.length > 0) {
          for (var c = 0; c < catHeaders.length; c++) {
            catHeaders[c].style.top = groupHeaderH + 'px';
          }
        }

        var catH = catHeaders.length > 0 ? catHeaders[0].getBoundingClientRect().height : 0;

        var subTop = groupHeaderH + catH;
        for (var j = 0; j < subHeaders.length; j++) {
          subHeaders[j].style.top = subTop + 'px';
        }
      }
    }

    function toggleArea(areaDiv, isChild) {
      var wasExpanded = areaDiv.classList.contains('expanded');
      // Extract area name from the div's id
      var areaName = null;
      for (var name in INVENTORY) {
        if (areaDiv.id === 'area_' + name.replace(/[^a-zA-Z0-9]/g, '_')) {
          areaName = name; break;
        }
      }
      
      if (isChild) {
        // Child areas within a parent group: only collapse sibling children
        var siblings = areaDiv.parentElement.querySelectorAll('.area-section');
        for (var i = 0; i < siblings.length; i++) {
          siblings[i].classList.remove('expanded');
        }
      } else {
        // Standalone areas: close all other standalone areas
        var allAreas = document.querySelectorAll('.areas-container > .area-section');
        for (var i = 0; i < allAreas.length; i++) {
          allAreas[i].classList.remove('expanded');
        }
      }
      
      // If it wasn't expanded, open it and scroll into view
      if (!wasExpanded) {
        areaDiv.classList.add('expanded');
        expandedArea = areaName;
        updateStickyOffsets();
        setTimeout(function() {
          if (isChild) {
            // For child areas inside a group, we need to scroll so the child
            // area header appears just below the parent group's sticky header.
            // scrollIntoView would put it at top:0, hidden behind the group header.
            var scrollParent = document.getElementById('areasContainer');
            if (scrollParent) {
              var areaRect = areaDiv.getBoundingClientRect();
              var scrollRect = scrollParent.getBoundingClientRect();
              // Group header sticks at top:0 with height ~45px
              var groupHeaderHeight = 45;
              var areaTopInView = areaRect.top - scrollRect.top;
              var targetScroll = scrollParent.scrollTop + areaTopInView - groupHeaderHeight;
              scrollParent.scrollTo({ top: Math.max(0, targetScroll), behavior: 'smooth' });
            }
          } else {
            areaDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }, 50);
      } else {
        expandedArea = null;
      }
    }

    function toggleAreaGroup(groupDiv) {
      var wasExpanded = groupDiv.classList.contains('expanded');
      // Extract group name from the div's id
      var groupName = null;
      for (var name in areaHierarchy) {
        if (groupDiv.id === 'area_group_' + name.replace(/[^a-zA-Z0-9]/g, '_')) {
          groupName = name; break;
        }
      }

      // Close all top-level groups and standalone areas
      var allGroups = document.querySelectorAll('.areas-container > .area-group');
      for (var i = 0; i < allGroups.length; i++) {
        allGroups[i].classList.remove('expanded');
        // Also collapse any expanded children inside
        var childAreas = allGroups[i].querySelectorAll('.area-section.expanded');
        for (var j = 0; j < childAreas.length; j++) {
          childAreas[j].classList.remove('expanded');
        }
      }
      var allStandalone = document.querySelectorAll('.areas-container > .area-section');
      for (var i = 0; i < allStandalone.length; i++) {
        allStandalone[i].classList.remove('expanded');
      }

      if (!wasExpanded) {
        groupDiv.classList.add('expanded');
        expandedGroup = groupName;
        updateStickyOffsets();
      } else {
        expandedGroup = null;
        expandedArea = null;
      }
    }
    

    function toggleCategory(areaName, catName, checked) {
      var items = INVENTORY[areaName][catName];
      for (var i = 0; i < items.length; i++) {
        var key = generateKey(areaName, catName, items[i].name);
        setItemValue(key, checked ? items[i].required : 0, true);
      }
      updateAllStatuses();
      updateSummary();

      if (checked) {
        // Trigger auto-advance if we just checked everything
        autoCategoryAdvance(areaName, catName);
        checkForCompletion();
      } else {
        // Reopen the category so the user can see what was unchecked
        var catKey = areaName + '::' + catName;
        collapsedCategories[catKey] = false;
        var itemsDiv = document.getElementById('cat_items_' + catKey.replace(/[^a-zA-Z0-9]/g, '_'));
        if (itemsDiv) itemsDiv.style.display = 'block';
        var icon = document.getElementById('cat_icon_' + catKey.replace(/[^a-zA-Z0-9]/g, '_'));
        if (icon) icon.style.transform = 'rotate(90deg)';
      }
    }
    
    function setItemValue(key, value, skipUpdate) {
      var parts = key.split('::');
      var item = findItem(parts[0], parts[1], parts[2]);
      var maxValue = item ? item.required : 9999;
      
      value = Math.max(0, Math.min(maxValue, value));
      itemStates[key] = { actual: value };
      
      // Update input
      var input = document.getElementById('input_' + key.replace(/[^a-zA-Z0-9]/g, '_'));
      if (input) input.value = value;
      
      // Update checkbox
      var parts = key.split('::');
      var item = findItem(parts[0], parts[1], parts[2]);
      if (item) {
        var itemDiv = document.getElementById('item_' + key.replace(/[^a-zA-Z0-9]/g, '_'));
        if (itemDiv) {
          var cb = itemDiv.querySelector('.item-checkbox');
          if (cb) cb.checked = value >= item.required;
          
          itemDiv.classList.remove('checked', 'short', 'missing');
          if (value >= item.required) itemDiv.classList.add('checked');
          else if (value > 0) itemDiv.classList.add('short');
          else itemDiv.classList.add('missing');
        }
      }
      
      if (!skipUpdate) {
        updateAllStatuses();
        updateSummary();

        // Auto-advance: if all items in this category are now OK,
        // collapse it and open the next incomplete category.
        var areaName = parts[0];
        var catName = parts[1];
        if (value >= (item ? item.required : 0)) {
          autoCategoryAdvance(areaName, catName);
        }

        checkForCompletion();
      }
    }

    // Check if all items in a category are OK
    function isCategoryComplete(areaName, catName) {
      var items = INVENTORY[areaName] && INVENTORY[areaName][catName];
      if (!items) return true;
      for (var i = 0; i < items.length; i++) {
        var key = generateKey(areaName, catName, items[i].name);
        var actual = (itemStates[key] || { actual: 0 }).actual;
        if (actual < items[i].required) return false;
      }
      return true;
    }

    // Collapse current category and open next incomplete one
    function autoCategoryAdvance(areaName, catName) {
      if (!isCategoryComplete(areaName, catName)) return;

      // Also check subcategories if this is a parent category
      var meta = categoryMeta[areaName + '::' + catName] || { level: 0 };
      if (meta.level === 0) {
        for (var sub in INVENTORY[areaName]) {
          var subMeta = categoryMeta[areaName + '::' + sub];
          if (subMeta && subMeta.level === 1 && subMeta.parent === catName) {
            if (!isCategoryComplete(areaName, sub)) return;
          }
        }
      }

      // Collapse current category
      var catKey = areaName + '::' + catName;
      // If this is a subcategory, collapse the subcategory
      if (meta.level === 1 && meta.parent) {
        // Check if sibling subcategories under the same parent are complete
        var parentCat = meta.parent;
        var allSubsDone = isCategoryComplete(areaName, parentCat);
        if (allSubsDone) {
          for (var sub in INVENTORY[areaName]) {
            var subMeta = categoryMeta[areaName + '::' + sub];
            if (subMeta && subMeta.level === 1 && subMeta.parent === parentCat) {
              if (!isCategoryComplete(areaName, sub)) { allSubsDone = false; break; }
            }
          }
        }
        if (allSubsDone) {
          // Collapse the parent category and advance to next top-level
          catName = parentCat;
          catKey = areaName + '::' + catName;
        } else {
          // Just collapse this subcategory — more subs to do
          collapsedCategories[catKey] = true;
          var itemsDiv = document.getElementById('cat_items_' + catKey.replace(/[^a-zA-Z0-9]/g, '_'));
          if (itemsDiv) itemsDiv.style.display = 'none';
          var icon = document.getElementById('cat_icon_' + catKey.replace(/[^a-zA-Z0-9]/g, '_'));
          if (icon) icon.style.transform = 'rotate(0deg)';
          return;
        }
      }

      // Collapse this top-level category
      collapsedCategories[catKey] = true;
      var itemsDiv = document.getElementById('cat_items_' + catKey.replace(/[^a-zA-Z0-9]/g, '_'));
      if (itemsDiv) itemsDiv.style.display = 'none';
      var icon = document.getElementById('cat_icon_' + catKey.replace(/[^a-zA-Z0-9]/g, '_'));
      if (icon) icon.style.transform = 'rotate(0deg)';

      // Find next incomplete top-level category in this area
      var catOrder = [];
      for (var c in INVENTORY[areaName]) {
        var cMeta = categoryMeta[areaName + '::' + c] || { level: 0 };
        if (cMeta.level === 0) catOrder.push(c);
      }
      var foundCurrent = false;
      for (var ci = 0; ci < catOrder.length; ci++) {
        if (catOrder[ci] === catName) { foundCurrent = true; continue; }
        if (!foundCurrent) continue;

        var nextCat = catOrder[ci];
        var nextComplete = isCategoryComplete(areaName, nextCat);
        // Also check subcategories
        if (nextComplete) {
          for (var sub in INVENTORY[areaName]) {
            var subMeta = categoryMeta[areaName + '::' + sub];
            if (subMeta && subMeta.level === 1 && subMeta.parent === nextCat) {
              if (!isCategoryComplete(areaName, sub)) { nextComplete = false; break; }
            }
          }
        }
        if (!nextComplete) {
          // Open this category
          var nextKey = areaName + '::' + nextCat;
          collapsedCategories[nextKey] = false;
          var nextItemsDiv = document.getElementById('cat_items_' + nextKey.replace(/[^a-zA-Z0-9]/g, '_'));
          if (nextItemsDiv) nextItemsDiv.style.display = 'block';
          var nextIcon = document.getElementById('cat_icon_' + nextKey.replace(/[^a-zA-Z0-9]/g, '_'));
          if (nextIcon) nextIcon.style.transform = 'rotate(90deg)';

          // Scroll to it, accounting for sticky area header
          var nextHeader = nextItemsDiv ? nextItemsDiv.previousElementSibling : null;
          if (nextHeader) {
            // Use triple rAF to ensure reflow completes after collapsing
            // (especially important when collapsing categories with subcategories)
            requestAnimationFrame(function() {
              requestAnimationFrame(function() {
                requestAnimationFrame(function() {
                  // Find the actual scroll container
                  var scrollParent = null;
                  var el = nextHeader.parentElement;
                  while (el) {
                    var style = window.getComputedStyle(el);
                    if (style.overflowY === 'auto' || style.overflowY === 'scroll') {
                      scrollParent = el;
                      break;
                    }
                    el = el.parentElement;
                  }
                  if (!scrollParent) scrollParent = document.documentElement;

                  // Measure the sticky header stack: find the bottom edge of
                  // the lowest sticky area-header in the top region of the viewport.
                  // Headers stick at various top values (0, 45px, etc.) so we
                  // check if a header's top is within the top half of the viewport.
                  var stickyOffset = 0;
                  var scrollRect = scrollParent.getBoundingClientRect();
                  var halfHeight = scrollRect.height / 2;
                  var stickyHeaders = scrollParent.querySelectorAll('.area-header');
                  for (var sh = 0; sh < stickyHeaders.length; sh++) {
                    var shStyle = window.getComputedStyle(stickyHeaders[sh]);
                    if (shStyle.position === 'sticky') {
                      var shRect = stickyHeaders[sh].getBoundingClientRect();
                      var relTop = shRect.top - scrollRect.top;
                      // Header is in the sticky zone if its top is in the
                      // upper portion of the scroll container
                      if (relTop >= -1 && relTop < halfHeight) {
                        var bottom = relTop + shRect.height;
                        if (bottom > stickyOffset) stickyOffset = bottom;
                      }
                    }
                  }
                  // Fallback minimum
                  if (stickyOffset < 45) stickyOffset = 45;

                  var headerRect = nextHeader.getBoundingClientRect();
                  var headerTopInView = headerRect.top - scrollRect.top;

                  // Always scroll to position the next category header just below
                  // the sticky header stack, unless it's already exactly there
                  if (Math.abs(headerTopInView - stickyOffset) > 2) {
                    var targetScroll = scrollParent.scrollTop + headerTopInView - stickyOffset;
                    scrollParent.scrollTo({ top: Math.max(0, targetScroll), behavior: 'smooth' });
                  }
                });
              });
            });
          }
          return;
        }
      }
    }
    
    function adjustItem(key, delta) {
      var current = (itemStates[key] || { actual: 0 }).actual;
      setItemValue(key, current + delta);
    }
    
    function findItem(areaName, catName, itemName) {
      if (INVENTORY[areaName] && INVENTORY[areaName][catName]) {
        var items = INVENTORY[areaName][catName];
        for (var i = 0; i < items.length; i++) {
          if (items[i].name === itemName) return items[i];
        }
      }
      return null;
    }
    

    // =====================================================
    // TAGGED AREA FUNCTIONS
    // =====================================================

    // Clear item quantities for unsealed areas so they don't persist
    function clearUnsealedItemStates() {
      for (var areaName in INVENTORY) {
        if (taggedAreas[areaName]) continue; // keep sealed area states
        for (var catName in INVENTORY[areaName]) {
          var items = INVENTORY[areaName][catName];
          for (var i = 0; i < items.length; i++) {
            var key = generateKey(areaName, catName, items[i].name);
            delete itemStates[key];
            delete restockStatus[key];
          }
        }
      }
    }

    // Auto-break is intentionally NOT performed for overdue seals.
    // Instead, overdue seals display a prominent visual warning in the UI
    // (via isReviewOverdue), and the user must manually confirm breaking them
    // using the "Break Seal & Review" button. This function is kept as a
    // hook in case automatic behavior is desired in the future.
    function autoBreakOverdueSeals() {
      // No-op: overdue seals are handled visually, requiring user confirmation.
      return false;
    }

    function isAreaAllOk(areaName) {
      if (!INVENTORY[areaName]) return true;
      for (var catName in INVENTORY[areaName]) {
        var items = INVENTORY[areaName][catName];
        for (var i = 0; i < items.length; i++) {
          var key = generateKey(areaName, catName, items[i].name);
          var actual = (itemStates[key] || { actual: 0 }).actual;
          if (actual < items[i].required) return false;
        }
      }
      return true;
    }

    function isAreaSealable(areaName) {
      if (taggedAreas[areaName]) return false;

      // For parent areas: all sealable children must already be sealed
      if (areaHierarchy[areaName]) {
        var children = areaHierarchy[areaName];
        for (var c = 0; c < children.length; c++) {
          if (sealableAreas[children[c]] && !taggedAreas[children[c]]) {
            return false;
          }
        }
      }

      // Own items must be OK or handled
      if (INVENTORY[areaName]) {
        for (var catName in INVENTORY[areaName]) {
          var items = INVENTORY[areaName][catName];
          for (var i = 0; i < items.length; i++) {
            var key = generateKey(areaName, catName, items[i].name);
            var actual = (itemStates[key] || { actual: 0 }).actual;
            if (actual >= items[i].required) continue;
            var status = restockStatus[key];
            if (status && (status.restocked || status.outOfStock)) continue;
            return false;
          }
        }
      }
      return true;
    }

    function sealAllAreas() {
      var sealed = 0;
      // Seal children first, then parents (parents require children to be sealed)
      // Pass 1: non-parent areas
      for (var areaName in INVENTORY) {
        if (areaHierarchy[areaName]) continue; // skip parents for now
        if (sealableAreas[areaName] && isAreaSealable(areaName)) {
          var now = new Date();
          taggedAreas[areaName] = {
            taggedDate: now.toISOString().split('T')[0],
            taggedTimestamp: now.getTime()
          };
          sealed++;
        }
      }
      // Pass 2: parent areas (now that children may be sealed)
      for (var areaName in areaHierarchy) {
        if (sealableAreas[areaName] && isAreaSealable(areaName)) {
          var now = new Date();
          taggedAreas[areaName] = {
            taggedDate: now.toISOString().split('T')[0],
            taggedTimestamp: now.getTime()
          };
          sealed++;
        }
      }
      if (sealed > 0) {
        closeRestockModal();
        buildUI();
        showCompletionPopup();
      }
    }

    function isEverythingComplete() {
      for (var areaName in INVENTORY) {
        if (taggedAreas[areaName]) continue;
        for (var catName in INVENTORY[areaName]) {
          var items = INVENTORY[areaName][catName];
          for (var i = 0; i < items.length; i++) {
            var key = generateKey(areaName, catName, items[i].name);
            var actual = (itemStates[key] || { actual: 0 }).actual;
            if (actual >= items[i].required) continue;
            var status = restockStatus[key];
            if (status && (status.restocked || status.outOfStock)) continue;
            return false;
          }
        }
      }
      return true;
    }

    function showCompletionPopup() {
      var msgEl = document.getElementById('completionMessage');
      if (enableTaggedAreas) {
        msgEl.textContent = 'Please make sure all areas marked as sealed have been tied off before continuing.';
      } else {
        msgEl.textContent = 'Please press Next.';
      }
      document.getElementById('completionOverlay').classList.add('open');
    }

    function closeCompletionPopup() {
      document.getElementById('completionOverlay').classList.remove('open');
    }

    // =====================================================
    // RESET DIALOG
    // =====================================================

    var selectedResetOption = null;

    // =====================================================
    // CHANGELOG DIALOG
    // =====================================================

    function openChangelog() {
      var body = document.getElementById('changelogBody');
      var html = '';
      for (var i = 0; i < CHANGELOG.length; i++) {
        var entry = CHANGELOG[i];
        html += '<div class="changelog-version">';
        html += '<div class="changelog-version-header">';
        html += '<span class="changelog-version-number">v' + escapeHtml(entry.version) + '</span>';
        if (entry.date) {
          html += '<span class="changelog-version-date">' + escapeHtml(entry.date) + '</span>';
        }
        html += '</div>';
        html += '<ul class="changelog-changes">';
        for (var j = 0; j < entry.changes.length; j++) {
          html += '<li>' + escapeHtml(entry.changes[j]) + '</li>';
        }
        html += '</ul>';
        html += '</div>';
      }
      body.innerHTML = html;
      document.getElementById('changelogOverlay').classList.add('open');
    }

    function closeChangelog() {
      document.getElementById('changelogOverlay').classList.remove('open');
    }

    function initVersionDisplay() {
      var el = document.getElementById('versionDisplay');
      if (el) el.textContent = 'v' + VERSION;
    }

    // =====================================================
    // RESET DIALOG
    // =====================================================

    function openResetDialog() {
      selectedResetOption = null;
      var options = document.querySelectorAll('.reset-option');
      for (var i = 0; i < options.length; i++) {
        options[i].classList.remove('selected', 'restore');
        var radio = options[i].querySelector('input[type="radio"]');
        if (radio) radio.checked = false;
      }
      document.getElementById('resetConfirmBtn').classList.remove('enabled');
      // Show the "Restore from last submission" option only if a Jotform API key is configured
      var jfOption = document.getElementById('resetJotformOption');
      if (jfOption) {
        var hasApiKey = false;
        try {
          hasApiKey = typeof JFCustomWidget !== 'undefined' && !!JFCustomWidget.getWidgetSetting('jotformApiKey');
        } catch (e) {}
        jfOption.style.display = hasApiKey ? '' : 'none';
      }
      document.getElementById('resetOverlay').classList.add('open');
    }

    function closeResetDialog() {
      document.getElementById('resetOverlay').classList.remove('open');
      selectedResetOption = null;
    }

    function selectResetOption(option) {
      selectedResetOption = option;
      var options = document.querySelectorAll('.reset-option');
      for (var i = 0; i < options.length; i++) {
        var radio = options[i].querySelector('input');
        var isThis = radio && radio.value === option;
        options[i].classList.toggle('selected', isThis);
        options[i].classList.toggle('restore', isThis && option === 'jotform');
      }
      var confirmBtn = document.getElementById('resetConfirmBtn');
      confirmBtn.classList.add('enabled');
      // Change button text/color for restore vs destructive reset
      if (option === 'jotform') {
        confirmBtn.textContent = 'Restore';
        confirmBtn.style.background = '#0066cc';
      } else {
        confirmBtn.textContent = 'Reset';
        confirmBtn.style.background = '';
      }
    }

    function confirmReset() {
      if (!selectedResetOption) return;

      if (selectedResetOption === 'jotform') {
        // Restore sealed state from most recent Jotform submission
        var apiKey, apiBase, formID, qid;
        try {
          apiKey = JFCustomWidget.getWidgetSetting('jotformApiKey');
          apiBase = JFCustomWidget.getWidgetSetting('jotformApiBase') || 'https://api.jotform.com';
          var fp = getFormParams();
          formID = fp.formID || cachedFormID || null;
          qid = fp.qid || null;
        } catch (e) {
          alert('Unable to access Jotform widget settings.');
          return;
        }
        if (!apiKey || !formID) {
          alert('Unable to restore: Jotform API key or form ID not available.');
          return;
        }

        // Clear all local state first
        itemStates = {};
        restockStatus = {};
        brokenSeals = [];
        collapsedCategories = {};
        taggedAreas = {};
        expandedArea = null;
        expandedGroup = null;
        try { localStorage.removeItem(getStorageKey()); } catch (e) {}
        try { localStorage.removeItem(getSealStorageKey()); } catch (e) {}

        closeResetDialog();

        // Fetch from server, forcing timestamp comparison to accept any remote data
        fetchLatestSealState(apiBase, formID, apiKey, qid, function(remote) {
          if (remote && remote.taggedAreas) {
            taggedAreas = remote.taggedAreas;
            if (remote.brokenSeals) brokenSeals = remote.brokenSeals;
          }
          // Rebuild regardless — either with restored seals or with a clean slate
          autoBreakOverdueSeals();
          clearUnsealedItemStates();
          buildUI();
          if (stateReady) {
            saveState();
            saveSealState();
          }
          resizeWidget();
        });
        return;
      }

      if (selectedResetOption === 'all') {
        if (!confirm('This will break ALL seals and reset every item to zero. Are you sure?')) return;
        // Break all seals
        for (var areaName in taggedAreas) {
          brokenSeals.push({
            area: areaName,
            reason: 'manual_reset',
            taggedDate: taggedAreas[areaName].taggedDate,
            brokenTimestamp: Date.now()
          });
        }
        taggedAreas = {};
        itemStates = {};
        restockStatus = {};
        collapsedCategories = {};
        try { localStorage.removeItem(getStorageKey()); } catch (e) {}
        try { localStorage.removeItem(getSealStorageKey()); } catch (e) {}
      } else {
        // Reset only unsealed areas
        for (var areaName in INVENTORY) {
          if (taggedAreas[areaName]) continue;
          for (var catName in INVENTORY[areaName]) {
            var items = INVENTORY[areaName][catName];
            for (var i = 0; i < items.length; i++) {
              var key = generateKey(areaName, catName, items[i].name);
              delete itemStates[key];
              delete restockStatus[key];
            }
          }
        }
        collapsedCategories = {};
      }

      closeResetDialog();
      expandedArea = null;
      expandedGroup = null;
      buildUI();
      if (stateReady) saveState();
    }

    function toggleCategoryCollapse(areaName, catName) {
      var key = areaName + '::' + catName;
      collapsedCategories[key] = !collapsedCategories[key];
      var itemsDiv = document.getElementById('cat_items_' + key.replace(/[^a-zA-Z0-9]/g, '_'));
      if (itemsDiv) {
        itemsDiv.style.display = collapsedCategories[key] ? 'none' : 'block';
      }
      var icon = document.getElementById('cat_icon_' + key.replace(/[^a-zA-Z0-9]/g, '_'));
      if (icon) {
        icon.style.transform = collapsedCategories[key] ? 'rotate(0deg)' : 'rotate(90deg)';
      }
    }

    function tagArea(areaName) {
      if (!sealableAreas[areaName]) return;
      if (!isAreaAllOk(areaName) && !isAreaSealable(areaName)) return;
      var now = new Date();
      taggedAreas[areaName] = {
        taggedDate: now.toISOString().split('T')[0],
        taggedTimestamp: now.getTime()
      };
      buildUI();
    }

    function breakSeal(areaName, reason) {
      // For parent areas, offer choice to also break child seals
      if (areaHierarchy[areaName]) {
        var hasSealableChildren = false;
        var children = areaHierarchy[areaName];
        for (var c = 0; c < children.length; c++) {
          if (sealableAreas[children[c]]) { hasSealableChildren = true; break; }
        }

        if (hasSealableChildren) {
          var choice = reason === 'missing'
            ? confirm('The seal for "' + areaName + '" is missing.\n\nPress OK to break ALL seals (parent + all children).\nPress Cancel to break only the parent seal.')
            : confirm('Breaking the seal for "' + areaName + '".\n\nPress OK to break ALL seals (parent + all children).\nPress Cancel to break only the parent seal.');

          // First confirm they actually want to break the parent
          var proceedMsg = reason === 'missing'
            ? 'This will reset items and require re-verification. Continue?'
            : 'Breaking the seal will reset items. You will need to re-verify. Continue?';
          if (!confirm(proceedMsg)) return;

          // Break parent
          var tagInfo = taggedAreas[areaName];
          brokenSeals.push({
            area: areaName,
            reason: reason || 'review',
            taggedDate: tagInfo ? tagInfo.taggedDate : null,
            brokenTimestamp: Date.now()
          });
          delete taggedAreas[areaName];

          if (INVENTORY[areaName]) {
            for (var catName in INVENTORY[areaName]) {
              var items = INVENTORY[areaName][catName];
              for (var i = 0; i < items.length; i++) {
                var key = generateKey(areaName, catName, items[i].name);
                itemStates[key] = { actual: 0 };
                delete restockStatus[key];
              }
            }
          }

          // If user chose to break all children too
          if (choice) {
            for (var c = 0; c < children.length; c++) {
              var childName = children[c];
              if (taggedAreas[childName]) {
                brokenSeals.push({
                  area: childName,
                  reason: 'parent_broken',
                  taggedDate: taggedAreas[childName].taggedDate,
                  brokenTimestamp: Date.now()
                });
                delete taggedAreas[childName];
              }
              // Reset child items regardless (they're part of the parent unit)
              if (INVENTORY[childName]) {
                for (var catName in INVENTORY[childName]) {
                  var items = INVENTORY[childName][catName];
                  for (var i = 0; i < items.length; i++) {
                    var key = generateKey(childName, catName, items[i].name);
                    itemStates[key] = { actual: 0 };
                    delete restockStatus[key];
                  }
                }
              }
            }
          }

          buildUI();
          return;
        }
      }

      // Standard break seal for non-parent areas (or parents without sealable children)
      var message = reason === 'missing'
        ? 'The seal for this area is missing. All items will be reset and you will need to re-verify every item. Continue?'
        : 'Breaking the seal will reset all items in this area. You will need to re-verify every item. Continue?';
      if (!confirm(message)) {
        return;
      }
      // Log the seal break
      var tagInfo = taggedAreas[areaName];
      brokenSeals.push({
        area: areaName,
        reason: reason || 'review',
        taggedDate: tagInfo ? tagInfo.taggedDate : null,
        brokenTimestamp: Date.now()
      });
      delete taggedAreas[areaName];

      // Reset all items in this area to 0
      if (INVENTORY[areaName]) {
        for (var catName in INVENTORY[areaName]) {
          var items = INVENTORY[areaName][catName];
          for (var i = 0; i < items.length; i++) {
            var key = generateKey(areaName, catName, items[i].name);
            itemStates[key] = { actual: 0 };
            delete restockStatus[key];
          }
        }
      }

      // If this is a child area, also break the parent seal
      if (areaParent[areaName] && taggedAreas[areaParent[areaName]]) {
        var parentName = areaParent[areaName];
        var parentTagInfo = taggedAreas[parentName];
        brokenSeals.push({
          area: parentName,
          reason: 'child_broken',
          taggedDate: parentTagInfo ? parentTagInfo.taggedDate : null,
          brokenTimestamp: Date.now()
        });
        delete taggedAreas[parentName];

        // Reset parent's own items too
        if (INVENTORY[parentName]) {
          for (var catName in INVENTORY[parentName]) {
            var items = INVENTORY[parentName][catName];
            for (var i = 0; i < items.length; i++) {
              var key = generateKey(parentName, catName, items[i].name);
              itemStates[key] = { actual: 0 };
              delete restockStatus[key];
            }
          }
        }
      }

      buildUI();
    }

    function formatTagDate(dateStr) {
      var parts = dateStr.split('-');
      var months = ['January', 'February', 'March', 'April', 'May', 'June',
                    'July', 'August', 'September', 'October', 'November', 'December'];
      return months[parseInt(parts[1], 10) - 1] + ' ' + parseInt(parts[2], 10) + ', ' + parts[0];
    }

    function daysSinceTagged(timestamp) {
      var now = new Date();
      var tagged = new Date(timestamp);
      var nowDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      var tagDate = new Date(tagged.getFullYear(), tagged.getMonth(), tagged.getDate());
      return Math.floor((nowDate - tagDate) / (1000 * 60 * 60 * 24));
    }

    // Check if the monthly review day has passed since the area was tagged
    function isReviewOverdue(taggedTimestamp) {
      if (sealReviewDay <= 0) return false;
      var now = new Date();
      var today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      var tagged = new Date(taggedTimestamp);
      var tagDate = new Date(tagged.getFullYear(), tagged.getMonth(), tagged.getDate());

      // Find the most recent review date (on or before today)
      var mostRecentReview;
      if (now.getDate() >= sealReviewDay) {
        // Review day already occurred this month
        mostRecentReview = new Date(now.getFullYear(), now.getMonth(), sealReviewDay);
      } else {
        // Review day hasn't come yet this month; last one was previous month
        mostRecentReview = new Date(now.getFullYear(), now.getMonth() - 1, sealReviewDay);
      }

      // If the area was tagged before the most recent review date, it's overdue
      return tagDate < mostRecentReview;
    }

    // Get the next upcoming review date
    function getNextReviewDate() {
      if (sealReviewDay <= 0) return null;
      var now = new Date();
      if (now.getDate() < sealReviewDay) {
        return new Date(now.getFullYear(), now.getMonth(), sealReviewDay);
      } else {
        return new Date(now.getFullYear(), now.getMonth() + 1, sealReviewDay);
      }
    }

    function getOrdinalSuffix(day) {
      if (day >= 11 && day <= 13) return 'th';
      switch (day % 10) {
        case 1: return 'st';
        case 2: return 'nd';
        case 3: return 'rd';
        default: return 'th';
      }
    }

    // =====================================================
    // STATUS UPDATES
    // =====================================================
    
    function updateAllStatuses() {
      for (var areaName in INVENTORY) {
        var areaId = 'area_' + areaName.replace(/[^a-zA-Z0-9]/g, '_');
        var areaDiv = document.getElementById(areaId);
        var statusEl = document.getElementById('status_' + areaId);

        // Handle tagged areas
        if (taggedAreas[areaName]) {
          if (areaDiv && statusEl) {
            var header = areaDiv.querySelector('.area-header');
            header.classList.remove('has-issues', 'all-ok', 'tagged', 'review-needed');
            statusEl.classList.remove('issues', 'ok', 'tagged', 'review-needed');

            var tagInfo = taggedAreas[areaName];
            var reviewNeeded = isReviewOverdue(tagInfo.taggedTimestamp);

            if (reviewNeeded) {
              header.classList.add('tagged', 'review-needed');
              statusEl.classList.add('review-needed');
              statusEl.textContent = 'REVIEW DUE';
            } else {
              header.classList.add('tagged');
              statusEl.classList.add('tagged');
              statusEl.textContent = 'SEALED';
            }
          }
          continue;
        }

        // Normal (non-tagged) area status
        var areaOk = 0, areaTotal = 0;

        for (var catName in INVENTORY[areaName]) {
          var catOk = 0;
          var items = INVENTORY[areaName][catName];
          var metaKey = areaName + '::' + catName;
          var meta = categoryMeta[metaKey] || { level: 0, parent: null };

          for (var i = 0; i < items.length; i++) {
            var key = generateKey(areaName, catName, items[i].name);
            var actual = (itemStates[key] || { actual: 0 }).actual;
            var status = restockStatus[key] || {};
            var isComplete = actual >= items[i].required || ((status.restocked || status.outOfStock) && actual < items[i].required);
            if (isComplete) {
              catOk++;
              areaOk++;
            }
            areaTotal++;
          }

          // Update this category/subcategory status
          var catStatusId = 'cat_status_' + generateKey(areaName, catName, '').replace(/[^a-zA-Z0-9]/g, '_');
          var catStatusEl = document.getElementById(catStatusId);
          if (catStatusEl) {
            // For parent categories, aggregate subcategory counts too
            if (meta.level === 0) {
              var parentOk = catOk;
              var parentTotal = items.length;
              for (var subCat in INVENTORY[areaName]) {
                var subMeta = categoryMeta[areaName + '::' + subCat];
                if (subMeta && subMeta.level === 1 && subMeta.parent === catName) {
                  var subItems = INVENTORY[areaName][subCat];
                  for (var si = 0; si < subItems.length; si++) {
                    var subKey = generateKey(areaName, subCat, subItems[si].name);
                    var subActual = (itemStates[subKey] || { actual: 0 }).actual;
                    var subStatus = restockStatus[subKey] || {};
                    var subComplete = subActual >= subItems[si].required || ((subStatus.restocked || subStatus.outOfStock) && subActual < subItems[si].required);
                    if (subComplete) parentOk++;
                    parentTotal++;
                  }
                }
              }
              catStatusEl.textContent = '(' + parentOk + '/' + parentTotal + ')';

              // Update parent category checkbox
              var catCb = catStatusEl.parentElement ? catStatusEl.parentElement.querySelector('.category-checkbox') : null;
              if (catCb) catCb.checked = (parentOk === parentTotal && parentTotal > 0);

              // Green tint for completed categories
              if (catStatusEl.parentElement) {
                catStatusEl.parentElement.classList.toggle('category-complete', parentOk === parentTotal && parentTotal > 0);
              }
            } else {
              catStatusEl.textContent = '(' + catOk + '/' + items.length + ')';

              // Update subcategory checkbox
              var catCb = catStatusEl.parentElement ? catStatusEl.parentElement.querySelector('.category-checkbox') : null;
              if (catCb) catCb.checked = (catOk === items.length && items.length > 0);

              // Green tint for completed subcategories
              if (catStatusEl.parentElement) {
                catStatusEl.parentElement.classList.toggle('category-complete', catOk === items.length && items.length > 0);
              }
            }
          }
        }

        if (areaDiv && statusEl) {
          var header = areaDiv.querySelector('.area-header');
          header.classList.remove('has-issues', 'all-ok', 'tagged', 'review-needed');
          statusEl.classList.remove('issues', 'ok', 'tagged', 'review-needed');

          statusEl.textContent = areaOk + '/' + areaTotal;

          if (areaOk === areaTotal) {
            header.classList.add('all-ok');
            statusEl.classList.add('ok');
          } else {
            header.classList.add('has-issues');
            statusEl.classList.add('issues');
          }
        }

        // Show/hide tag button (show if area is marked sealable and all conditions met)
        if (sealableAreas[areaName]) {
          var tagBtn = document.getElementById('tag_btn_' + areaName.replace(/[^a-zA-Z0-9]/g, '_'));
          if (tagBtn) {
            tagBtn.style.display = isAreaSealable(areaName) ? 'block' : 'none';
          }
        }
      }

      // Update parent group statuses
      for (var parentName in areaHierarchy) {
        var children = areaHierarchy[parentName];
        var groupStatusEl = document.getElementById('status_group_' + parentName.replace(/[^a-zA-Z0-9]/g, '_'));
        var groupDiv = document.getElementById('area_group_' + parentName.replace(/[^a-zA-Z0-9]/g, '_'));
        if (!groupStatusEl || !groupDiv) continue;

        var groupHeader = groupDiv.querySelector(':scope > .area-header');
        if (!groupHeader) continue;
        groupHeader.classList.remove('has-issues', 'all-ok', 'tagged', 'review-needed');
        groupStatusEl.classList.remove('issues', 'ok', 'tagged', 'review-needed');

        // If parent itself is sealed
        if (taggedAreas[parentName]) {
          var parentReview = isReviewOverdue(taggedAreas[parentName].taggedTimestamp);
          if (parentReview) {
            groupHeader.classList.add('tagged', 'review-needed');
            groupStatusEl.classList.add('review-needed');
            groupStatusEl.textContent = 'REVIEW DUE';
          } else {
            groupHeader.classList.add('tagged');
            groupStatusEl.classList.add('tagged');
            groupStatusEl.textContent = 'SEALED';
          }
          continue;
        }

        // Parent not sealed — aggregate children + parent own items
        var totalChildren = 0;
        var sealedChildren = 0;
        var okChildren = 0;
        var anyReviewNeeded = false;

        for (var ci = 0; ci < children.length; ci++) {
          var childName = children[ci];
          if (!INVENTORY[childName]) continue;
          totalChildren++;

          if (taggedAreas[childName]) {
            sealedChildren++;
            if (isReviewOverdue(taggedAreas[childName].taggedTimestamp)) {
              anyReviewNeeded = true;
            }
          } else if (isAreaAllOk(childName)) {
            okChildren++;
          }
        }

        // Count parent's own items
        var parentOk = 0, parentTotal = 0;
        if (INVENTORY[parentName]) {
          for (var catName in INVENTORY[parentName]) {
            var items = INVENTORY[parentName][catName];
            for (var pi = 0; pi < items.length; pi++) {
              parentTotal++;
              var key = generateKey(parentName, catName, items[pi].name);
              var actual = (itemStates[key] || { actual: 0 }).actual;
              if (actual >= items[pi].required) parentOk++;
            }
          }
        }

        var allChildrenDone = (sealedChildren + okChildren === totalChildren) && totalChildren > 0;
        var parentItemsOk = parentOk === parentTotal;

        if (allChildrenDone && parentItemsOk) {
          if (anyReviewNeeded) {
            groupHeader.classList.add('tagged', 'review-needed');
            groupStatusEl.classList.add('review-needed');
            groupStatusEl.textContent = 'REVIEW DUE';
          } else {
            groupHeader.classList.add('all-ok');
            groupStatusEl.classList.add('ok');
            groupStatusEl.textContent = '✓';
          }
        } else {
          groupHeader.classList.add('has-issues');
          groupStatusEl.classList.add('issues');
          var parts = [];
          if (totalChildren > 0) parts.push((sealedChildren + okChildren) + '/' + totalChildren + ' areas');
          if (parentTotal > 0) parts.push(parentOk + '/' + parentTotal + ' items');
          groupStatusEl.textContent = parts.join(', ');
        }

        // Show/hide parent seal button
        if (sealableAreas[parentName]) {
          var tagBtn = document.getElementById('tag_btn_group_' + parentName.replace(/[^a-zA-Z0-9]/g, '_'));
          if (tagBtn) {
            tagBtn.style.display = isAreaSealable(parentName) ? 'block' : 'none';
          }
        }
      }
    }
    
    function updateSummary() {
      // Helper to build a single shortage item's HTML
      function buildShortageItemHtml(item) {
        var status = restockStatus[item.key] || {};
        var itemClass = '';
        if (status.restocked) itemClass = 'restocked';
        else if (status.outOfStock) itemClass = 'out-of-stock';

        var qtyClass = 'shortage-item-qty';
        var qtyText = '\u00d7' + item.shortage;
        if (status.restocked || status.outOfStock) {
          qtyClass += ' handled';
        } else if (item.isPartial) {
          qtyClass += ' partial';
        }
        
        var h = '<div class="shortage-item ' + itemClass + '" data-key="' + escapeHtml(item.key) + '">';
        h += '<span class="' + qtyClass + '">' + qtyText + '</span>';
        h += '<div class="shortage-item-name">' + escapeHtml(item.name) + '</div>';
        
        if (status.restocked) {
          h += '<button class="action-btn undo" onclick="undoRestock(\'' + escapeHtml(item.key) + '\')">Undo</button>';
        } else if (status.outOfStock) {
          h += '<button class="action-btn undo" onclick="undoRestock(\'' + escapeHtml(item.key) + '\')">Undo</button>';
        } else {
          h += '<div class="shortage-item-actions">';
          h += '<button class="action-btn restock" onclick="markRestocked(\'' + escapeHtml(item.key) + '\')">✓ Restocked</button>';
          h += '<button class="action-btn out-of-stock" onclick="openOutOfStockDialog(\'' + escapeHtml(item.key) + '\', \'' + escapeHtml(item.name) + '\')">Out of Stock</button>';
          h += '</div>';
        }
        
        h += '</div>';
        return h;
      }

      var shortages = [];
      var okCount = 0, shortCount = 0, missingCount = 0;

      for (var areaName in INVENTORY) {
        if (taggedAreas[areaName]) continue; // Skip sealed areas
        for (var catName in INVENTORY[areaName]) {
          var items = INVENTORY[areaName][catName];
          for (var i = 0; i < items.length; i++) {
            var key = generateKey(areaName, catName, items[i].name);
            var actual = (itemStates[key] || { actual: 0 }).actual;
            var required = items[i].required;
            
            if (actual >= required) {
              okCount++;
            } else {
              var shortage = required - actual;
              if (actual > 0) {
                shortCount++;
              } else {
                missingCount++;
              }
              shortages.push({
                key: key,
                area: areaName,
                category: catName,
                name: items[i].name,
                required: required,
                actual: actual,
                shortage: shortage,
                isPartial: actual > 0
              });
            }
          }
        }
      }
      
      // Update floating button
      var restockBtn = document.getElementById('restockBtn');
      var restockCount = document.getElementById('restockCount');
      var totalIssues = shortCount + missingCount;
      
      // Count how many are not yet handled
      var unhandledCount = 0;
      for (var j = 0; j < shortages.length; j++) {
        var status = restockStatus[shortages[j].key];
        if (!status || (!status.restocked && !status.outOfStock)) {
          unhandledCount++;
        }
      }
      
      restockCount.textContent = unhandledCount;
      
      if (totalIssues === 0 || unhandledCount === 0) {
        restockBtn.classList.add('all-ok');
        restockBtn.querySelector('.restock-icon').textContent = '✓';
        restockBtn.querySelector('span:nth-child(2)').textContent = 'All Stocked';
      } else {
        restockBtn.classList.remove('all-ok');
        restockBtn.querySelector('.restock-icon').textContent = '!';
        restockBtn.querySelector('span:nth-child(2)').textContent = 'Restock';
      }
      
      var summaryContent = document.getElementById('summaryContent');
      var modalFooter = document.getElementById('modalFooter');
      
      // Show/hide seal-all button in modal
      var sealAllBtn = document.getElementById('sealAllBtn');
      if (sealAllBtn) {
        var anySealable = false;
        if (enableTaggedAreas) {
          for (var sArea in INVENTORY) {
            if (sealableAreas[sArea] && isAreaSealable(sArea)) { anySealable = true; break; }
          }
        }
        sealAllBtn.style.display = anySealable ? 'flex' : 'none';
      }

      if (shortages.length === 0) {
        summaryContent.innerHTML = '<div class="summary-empty"><div class="icon">✓</div><div>All items fully stocked!</div></div>';
        modalFooter.style.display = (sealAllBtn && anySealable) ? 'block' : 'none';
      } else {
        modalFooter.style.display = 'block';
        
        // Build hierarchy: area -> category -> items
        // Respect the same structure as the main checklist
        var byArea = {};
        var areaOrder = [];
        for (var j = 0; j < shortages.length; j++) {
          var s = shortages[j];
          if (!byArea[s.area]) {
            byArea[s.area] = {};
            areaOrder.push(s.area);
          }
          if (!byArea[s.area][s.category]) {
            byArea[s.area][s.category] = [];
          }
          byArea[s.area][s.category].push(s);
        }
        
        var html = '';
        for (var ai = 0; ai < areaOrder.length; ai++) {
          var area = areaOrder[ai];
          var cats = byArea[area];

          // Check if this area is a child of a parent group
          var parentName = areaParent[area] || null;
          var areaLabel = parentName
            ? escapeHtml(parentName) + ' &rsaquo; ' + escapeHtml(area)
            : escapeHtml(area);

          html += '<div class="shortage-group">';
          html += '<div class="shortage-group-header">' + areaLabel + '</div>';
          
          // Group categories in display order: top-level, then subcategories under their parent
          var catOrder = [];
          var catChildren = {};
          for (var catName in cats) {
            var metaKey = area + '::' + catName;
            var meta = categoryMeta[metaKey] || { level: 0, parent: null };
            if (meta.level === 0) {
              catOrder.push(catName);
              if (!catChildren[catName]) catChildren[catName] = [];
            } else if (meta.parent) {
              if (!catChildren[meta.parent]) catChildren[meta.parent] = [];
              catChildren[meta.parent].push(catName);
            }
          }

          // Also include parent categories that have no direct shortages but have sub-shortages
          for (var catName in cats) {
            var metaKey = area + '::' + catName;
            var meta = categoryMeta[metaKey] || { level: 0, parent: null };
            if (meta.level === 1 && meta.parent) {
              if (catOrder.indexOf(meta.parent) === -1) {
                catOrder.push(meta.parent);
              }
              if (!catChildren[meta.parent]) catChildren[meta.parent] = [];
              if (catChildren[meta.parent].indexOf(catName) === -1) {
                catChildren[meta.parent].push(catName);
              }
            }
          }

          for (var ci = 0; ci < catOrder.length; ci++) {
            var topCat = catOrder[ci];
            var topCatItems = cats[topCat] || [];
            var subCats = catChildren[topCat] || [];
            var hasSubCats = subCats.length > 0;
            var hasDirectItems = topCatItems.length > 0;

            // Wrap each top-level category in its own container so sticky
            // subcategory headers are scoped to this category section and
            // don't stay stuck when scrolling into the next category.
            html += '<div class="shortage-cat-section">';

            // Show category header if there are direct items or subcategories
            if (hasDirectItems || hasSubCats) {
              html += '<div class="shortage-cat-header">' + escapeHtml(topCat) + '</div>';
            }

            // Direct items under this top-level category
            for (var k = 0; k < topCatItems.length; k++) {
              html += buildShortageItemHtml(topCatItems[k]);
            }

            // Subcategories
            for (var si = 0; si < subCats.length; si++) {
              var subCatName = subCats[si];
              var subCatItems = cats[subCatName] || [];
              if (subCatItems.length === 0) continue;

              var subMeta = categoryMeta[area + '::' + subCatName];
              var subDisplayName = (subMeta && subMeta.displayName) || subCatName;
              html += '<div class="shortage-subcat-header">' + escapeHtml(subDisplayName) + '</div>';

              for (var k = 0; k < subCatItems.length; k++) {
                html += buildShortageItemHtml(subCatItems[k]);
              }
            }

            html += '</div>'; // close shortage-cat-section
          }
          
          html += '</div>';
        }
        
        summaryContent.innerHTML = html;

        // Dynamically set sticky tops for modal headers
        updateModalStickyOffsets();
      }

      saveState();
    }

    // Dynamically set sticky tops for modal area/category/subcategory headers
    function updateModalStickyOffsets() {
      var modalBody = document.getElementById('summaryContent');
      if (!modalBody) return;
      var areaHeaders = modalBody.querySelectorAll('.shortage-group-header');
      var catHeaders = modalBody.querySelectorAll('.shortage-cat-header');
      var subHeaders = modalBody.querySelectorAll('.shortage-subcat-header');
      
      var areaH = 0;
      if (areaHeaders.length > 0) {
        areaH = areaHeaders[0].getBoundingClientRect().height;
      }
      var catH = 0;
      if (catHeaders.length > 0) {
        for (var i = 0; i < catHeaders.length; i++) {
          catHeaders[i].style.top = areaH + 'px';
        }
        catH = catHeaders[0].getBoundingClientRect().height;
      }
      if (subHeaders.length > 0) {
        var subTop = areaH + catH;
        for (var i = 0; i < subHeaders.length; i++) {
          subHeaders[i].style.top = subTop + 'px';
        }
      }
    }

    // Check if all items are fully stocked and show completion popup
    function checkForCompletion() {
      if (!stateReady) return;
      if (!isEverythingComplete()) return;
      // Small delay so the last category collapse/scroll finishes first
      setTimeout(function() {
        showCompletionPopup();
      }, 300);
    }

    function escapeHtml(text) {
      var div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    function openRestockModal() {
      if (isEverythingComplete()) {
        showCompletionPopup();
        return;
      }
      document.getElementById('modalOverlay').classList.add('open');
      // Sticky offsets need measurement after the modal is visible
      requestAnimationFrame(function() {
        updateModalStickyOffsets();
      });
    }
    
    function closeRestockModal() {
      document.getElementById('modalOverlay').classList.remove('open');
    }
    
    function markRestocked(key) {
      restockStatus[key] = { restocked: true, outOfStock: false, reason: '' };
      updateChecklistItem(key);
      updateAllStatuses();
      updateSummary();
      // Check if everything is now complete
      if (isEverythingComplete()) {
        closeRestockModal();
        showCompletionPopup();
      }
    }
    
    // Update a single checklist item in the main view
    function updateChecklistItem(key) {
      var parts = key.split('::');
      var areaName = parts[0];
      var catName = parts[1];
      var itemName = parts[2];
      var item = findItem(areaName, catName, itemName);
      if (item) {
        var itemDiv = document.getElementById('item_' + key.replace(/[^a-zA-Z0-9]/g, '_'));
        if (itemDiv) {
          var newRow = buildItemRow(areaName, catName, item);
          itemDiv.parentNode.replaceChild(newRow, itemDiv);
        }
      }
    }
    
    function openOutOfStockDialog(key, name) {
      currentOutOfStockKey = key;
      selectedReason = null;
      document.getElementById('dialogItemName').textContent = name;
      document.getElementById('outOfStockReason').value = '';
      document.getElementById('otherReasonContainer').classList.remove('visible');
      document.getElementById('confirmBtn').disabled = true;
      
      // Reset all reason buttons
      var buttons = document.querySelectorAll('.reason-btn');
      for (var i = 0; i < buttons.length; i++) {
        buttons[i].classList.remove('selected');
      }
      
      document.getElementById('dialogOverlay').classList.add('open');
    }
    
    function closeOutOfStockDialog() {
      document.getElementById('dialogOverlay').classList.remove('open');
      currentOutOfStockKey = null;
      selectedReason = null;
    }
    
    function selectReason(btn, reason) {
      // Remove selected from all buttons
      var buttons = document.querySelectorAll('.reason-btn');
      for (var i = 0; i < buttons.length; i++) {
        buttons[i].classList.remove('selected');
      }
      
      // Select this button
      btn.classList.add('selected');
      
      // Handle "other" option
      var otherContainer = document.getElementById('otherReasonContainer');
      if (reason === 'other') {
        otherContainer.classList.add('visible');
        selectedReason = null; // Will be set from textarea
        document.getElementById('confirmBtn').disabled = true;
        document.getElementById('outOfStockReason').focus();
      } else {
        otherContainer.classList.remove('visible');
        selectedReason = reason;
        document.getElementById('confirmBtn').disabled = false;
      }
    }
    
    function confirmOutOfStock() {
      if (currentOutOfStockKey) {
        var reason = selectedReason;
        if (!reason) {
          reason = document.getElementById('outOfStockReason').value.trim();
        }
        if (reason) {
          restockStatus[currentOutOfStockKey] = { restocked: false, outOfStock: true, reason: reason };
          updateChecklistItem(currentOutOfStockKey);
          closeOutOfStockDialog();
          updateAllStatuses();
          updateSummary();
          // Check if everything is now complete
          if (isEverythingComplete()) {
            closeRestockModal();
            showCompletionPopup();
          }
        }
      }
    }
    
    function undoRestock(key) {
      delete restockStatus[key];
      updateChecklistItem(key);
      updateAllStatuses();
      updateSummary();
    }
    
    function restockAllItems() {
      // Get all shortage keys and mark them restocked
      var restockedKeys = [];
      for (var areaName in INVENTORY) {
        if (taggedAreas[areaName]) continue; // Skip sealed areas
        for (var catName in INVENTORY[areaName]) {
          var items = INVENTORY[areaName][catName];
          for (var i = 0; i < items.length; i++) {
            var key = generateKey(areaName, catName, items[i].name);
            var actual = (itemStates[key] || { actual: 0 }).actual;
            var required = items[i].required;
            
            if (actual < required) {
              var status = restockStatus[key];
              // Only mark as restocked if not already marked as out of stock
              if (!status || !status.outOfStock) {
                restockStatus[key] = { restocked: true, outOfStock: false, reason: '' };
                restockedKeys.push(key);
              }
            }
          }
        }
      }
      // Update all affected checklist items
      for (var k = 0; k < restockedKeys.length; k++) {
        updateChecklistItem(restockedKeys[k]);
      }
      updateAllStatuses();
      updateSummary();
      // After restocking all, check if everything is complete
      if (isEverythingComplete()) {
        closeRestockModal();
        showCompletionPopup();
      }
    }

    // =====================================================
    // JOTFORM INTEGRATION
    // =====================================================
    
    function generateSubmitValue() {
      var restockedItems = [];
      var unavailableItems = [];

      for (var key in restockStatus) {
        var status = restockStatus[key];
        if (!status) continue;

        var parts = key.split('::');
        var areaName = parts[0];
        var catName = parts[1];
        var itemName = parts[2];

        // Skip items in tagged areas
        if (taggedAreas[areaName]) continue;

        // Find the item details
        var item = findItem(areaName, catName, itemName);
        if (!item) continue;

        var actual = (itemStates[key] || { actual: 0 }).actual;
        var shortage = item.required - actual;

        if (status.restocked) {
          restockedItems.push({
            area: areaName,
            category: catName,
            name: itemName,
            quantityRestocked: shortage
          });
        } else if (status.outOfStock) {
          unavailableItems.push({
            area: areaName,
            category: catName,
            name: itemName,
            quantityNeeded: shortage,
            reason: status.reason || 'No reason provided'
          });
        }
      }

      // Build tagged areas list for report
      var taggedList = [];
      for (var taggedArea in taggedAreas) {
        var info = taggedAreas[taggedArea];
        var days = daysSinceTagged(info.taggedTimestamp);
        var needsReview = isReviewOverdue(info.taggedTimestamp);
        taggedList.push({
          area: taggedArea,
          taggedDate: info.taggedDate,
          daysSinceTagged: days,
          reviewNeeded: needsReview
        });
      }

      // Generate plain-text report for JotForm submission display.
      // JotForm collapses whitespace/newlines in submission values, so we
      // use <br> tags for line breaks — JotForm renders these in its viewer.
      var now = new Date();
      var months = ['January', 'February', 'March', 'April', 'May', 'June',
                    'July', 'August', 'September', 'October', 'November', 'December'];
      var hours = now.getHours();
      var ampm = hours >= 12 ? 'PM' : 'AM';
      var h = hours % 12 || 12;
      var min = now.getMinutes() < 10 ? '0' + now.getMinutes() : '' + now.getMinutes();
      var dateHeader = months[now.getMonth()] + ' ' + now.getDate() + ', ' + now.getFullYear() + ' at ' + h + ':' + min + ' ' + ampm;

      // Helper: group an array of items by their .area property
      var groupByArea = function(items) {
        var groups = {};
        var order = [];
        for (var i = 0; i < items.length; i++) {
          var area = items[i].area;
          if (!groups[area]) { groups[area] = []; order.push(area); }
          groups[area].push(items[i]);
        }
        return { groups: groups, order: order };
      };

      // Build summary line
      var summaryParts = [];
      if (restockedItems.length > 0) summaryParts.push(restockedItems.length + ' restocked');
      if (unavailableItems.length > 0) summaryParts.push(unavailableItems.length + ' unavailable');
      if (brokenSeals.length > 0) summaryParts.push(brokenSeals.length + ' broken seal' + (brokenSeals.length > 1 ? 's' : ''));
      if (taggedList.length > 0) summaryParts.push(taggedList.length + ' sealed area' + (taggedList.length > 1 ? 's' : ''));

      // Build plain-text report (JotForm entity-encodes HTML, so plain text
      // is the only format that stays readable in submission views).
      var lines = [];
      lines.push('INVENTORY CHECK REPORT');
      lines.push(dateHeader);
      lines.push('════════════════════════════════════════');

      if (summaryParts.length > 0) {
        lines.push('Summary: ' + summaryParts.join(', '));
      } else {
        lines.push('All items accounted for. No restock actions needed.');
      }
      lines.push('');

      // --- Broken Seals ---
      if (brokenSeals.length > 0) {
        lines.push('⛔ BROKEN SEALS (' + brokenSeals.length + ')');
        lines.push('────────────────────────────────────────');
        for (var b = 0; b < brokenSeals.length; b++) {
          var bs = brokenSeals[b];
          var reasonLabel = bs.reason === 'missing' ? 'Seal was missing' : 'Scheduled review';
          var bLine = '  • ' + bs.area + ' — ' + reasonLabel;
          if (bs.taggedDate) {
            bLine += ' (sealed since ' + formatTagDate(bs.taggedDate) + ')';
          }
          lines.push(bLine);
        }
        lines.push('');
      }

      // --- Sealed / Tagged Areas ---
      if (taggedList.length > 0) {
        lines.push('🔒 SEALED / TAGGED AREAS (' + taggedList.length + ')');
        lines.push('────────────────────────────────────────');
        for (var t = 0; t < taggedList.length; t++) {
          var ta = taggedList[t];
          var tLine = '  • ' + ta.area + ' — Tagged: ' + formatTagDate(ta.taggedDate) + ' (' + ta.daysSinceTagged + ' days)';
          if (ta.reviewNeeded) {
            tLine += ' [REVIEW OVERDUE]';
          }
          lines.push(tLine);
        }
        lines.push('');
      }

      // --- Restocked Items (grouped by area) ---
      if (restockedItems.length > 0) {
        var rGrouped = groupByArea(restockedItems);
        lines.push('✅ RESTOCKED ITEMS (' + restockedItems.length + ')');
        lines.push('────────────────────────────────────────');
        for (var ri = 0; ri < rGrouped.order.length; ri++) {
          var rArea = rGrouped.order[ri];
          var rItems = rGrouped.groups[rArea];
          lines.push('  ' + rArea + ':');
          for (var rj = 0; rj < rItems.length; rj++) {
            lines.push('    • ' + rItems[rj].name + ' (x' + rItems[rj].quantityRestocked + ')');
          }
        }
        lines.push('');
      }

      // --- Unavailable Items (grouped by area) ---
      if (unavailableItems.length > 0) {
        var uGrouped = groupByArea(unavailableItems);
        lines.push('❌ UNAVAILABLE ITEMS (' + unavailableItems.length + ')');
        lines.push('────────────────────────────────────────');
        for (var ui = 0; ui < uGrouped.order.length; ui++) {
          var uArea = uGrouped.order[ui];
          var uItems = uGrouped.groups[uArea];
          lines.push('  ' + uArea + ':');
          for (var uj = 0; uj < uItems.length; uj++) {
            lines.push('    • ' + uItems[uj].name + ' (need ' + uItems[uj].quantityNeeded + ')');
            lines.push('      Reason: ' + uItems[uj].reason);
          }
        }
        lines.push('');
      }

      var report = lines.join('\n');

      // Machine-readable sync data (consumed by cross-device seal sync
      // and form-edit restoration — do not remove)
      var syncData = {
        taggedAreas: taggedAreas,
        brokenSeals: brokenSeals,
        itemStates: itemStates,
        restockStatus: restockStatus,
        timestamp: Date.now()
      };

      return {
        report: report,
        syncData: syncData
      };
    }
    
    function resizeWidget() {
      if (typeof JFCustomWidget !== 'undefined') {
        JFCustomWidget.requestFrameResize({ height: document.body.scrollHeight });
      }
    }
    
    // =====================================================
    // INIT
    // =====================================================
    
    function init() {
      initVersionDisplay();

      // Add input handler for other reason textarea
      document.getElementById('outOfStockReason').addEventListener('input', function() {
        var hasText = this.value.trim().length > 0;
        document.getElementById('confirmBtn').disabled = !hasText;
      });

      // Forward touch events from footer to scroll container
      var footer = document.querySelector('.restock-footer');
      var scrollContainer = document.getElementById('areasContainer');
      if (footer && scrollContainer) {
        var touchStartY = 0;
        var scrollStartTop = 0;

        footer.addEventListener('touchstart', function(e) {
          // Only handle if touch is on footer padding, not the button
          if (e.target === footer) {
            touchStartY = e.touches[0].clientY;
            scrollStartTop = scrollContainer.scrollTop;
          }
        }, { passive: true });

        footer.addEventListener('touchmove', function(e) {
          if (e.target === footer) {
            var deltaY = touchStartY - e.touches[0].clientY;
            scrollContainer.scrollTop = scrollStartTop + deltaY;
          }
        }, { passive: true });
      }
      
      if (typeof JFCustomWidget !== 'undefined' && JFCustomWidget.subscribe) {
        JFCustomWidget.subscribe('ready', function(data) {
          console.log('[Widget] Ready', data);
          console.log('[Widget] JFCustomWidget methods:', Object.keys(JFCustomWidget));
          
          // Cache formID for later use (e.g. reset-to-server)
          var fp = getFormParams();
          cachedFormID = fp.formID || (data && data.formID) || null;

          // Load inventory from widget settings
          var inventoryText = JFCustomWidget.getWidgetSetting('inventoryItems') || DEFAULT_INVENTORY;
          INVENTORY = parseInventory(inventoryText);

          // Derive tagged area support from per-area Sealable: config
          enableTaggedAreas = Object.keys(sealableAreas).length > 0;
          var reviewDay = JFCustomWidget.getWidgetSetting('sealReviewDay');
          if (reviewDay !== undefined && reviewDay !== null && reviewDay !== '') {
            sealReviewDay = Math.max(1, Math.min(31, parseInt(reviewDay, 10) || 0));
          }

          buildUI();

          // Restore saved state: try JotForm value first, then localStorage
          var saved = null;
          var isLocalRestore = false;
          if (data.value) {
            saved = extractSyncData(data.value);
          }
          if (!saved) {
            saved = loadState();
            if (saved) isLocalRestore = true;
          }
          if (saved) {
            // Decode HTML entities that Jotform may have injected into keys
            var _decEnt = function(s) { var t = document.createElement('textarea'); t.innerHTML = s; return t.value; };
            var _decKeys = function(o) { if (!o || typeof o !== 'object') return o; var d = {}; for (var k in o) d[_decEnt(k)] = o[k]; return d; };
            if (saved.taggedAreas) saved.taggedAreas = _decKeys(saved.taggedAreas);
            if (saved.itemStates) saved.itemStates = _decKeys(saved.itemStates);
            if (saved.restockStatus) saved.restockStatus = _decKeys(saved.restockStatus);

            if (saved.itemStates) {
              itemStates = saved.itemStates;
            }
            if (saved.taggedAreas) {
              taggedAreas = saved.taggedAreas;
            }
            if (saved.restockStatus) {
              restockStatus = saved.restockStatus;
            }
            if (saved.brokenSeals) {
              brokenSeals = saved.brokenSeals;
            }
          }

          // Always layer in the dedicated sealed-state store so that seals
          // persist across submissions and across users on the same device,
          // even when the per-submission state above is empty / stale.
          var sealData = loadSealState();
          if (sealData && sealData.taggedAreas) {
            // Use the more recent source for sealed state
            var savedSealTs = (saved && saved.timestamp) || 0;
            var dedicatedSealTs = sealData.timestamp || 0;
            if (dedicatedSealTs >= savedSealTs) {
              taggedAreas = sealData.taggedAreas;
              if (sealData.brokenSeals) {
                brokenSeals = sealData.brokenSeals;
              }
            }
          }

          // Auto-break any seals past the review day
          autoBreakOverdueSeals();

          // Clear item quantities for unsealed areas only on fresh sessions
          // (not same-device refreshes where the user is mid-checklist).
          if (!isLocalRestore) {
            clearUnsealedItemStates();
          }

          buildUI();

          // Capture the seal timestamp BEFORE saveState() overwrites it,
          // so the API fetch comparison uses the real prior value.
          var preSaveSealTs = 0;
          var preSaveSeal = loadSealState();
          if (preSaveSeal) preSaveSealTs = preSaveSeal.timestamp || 0;

          stateReady = true;
          saveState();
          resizeWidget();

          // ---- Cross-device: fetch sealed state from most recent submission ----
          // Requires the form admin to set a "jotformApiKey" widget setting
          // (a read-only JotForm API key is sufficient).
          var apiKey = JFCustomWidget.getWidgetSetting('jotformApiKey');
          if (apiKey) {
            var apiBase = JFCustomWidget.getWidgetSetting('jotformApiBase') || 'https://api.jotform.com';
            var fp = getFormParams();
            var formID = fp.formID || (data && data.formID) || null;
            var qid = fp.qid || null;
            // Use the timestamp from BEFORE saveState() wrote a fresh one
            var localTs = preSaveSealTs;

            fetchLatestSealState(apiBase, formID, apiKey, qid, function(remote) {
              if (remote && remote.taggedAreas && remote.timestamp > localTs) {
                taggedAreas = remote.taggedAreas;
                if (remote.brokenSeals) brokenSeals = remote.brokenSeals;
                autoBreakOverdueSeals();
                clearUnsealedItemStates();
                buildUI();
                saveSealState();
                resizeWidget();
              }
            });
          }
        });

        JFCustomWidget.subscribe('submit', function() {
          // Push final report to hidden field before submit
          pushReportToHiddenField();
          // Widget value carries only sync data for cross-device restoration
          var syncData = {
            taggedAreas: taggedAreas,
            brokenSeals: brokenSeals,
            itemStates: itemStates,
            restockStatus: restockStatus,
            timestamp: Date.now()
          };
          JFCustomWidget.sendSubmit({
            valid: true,
            value: JSON.stringify(syncData)
          });

          // Clear per-submission state so the next session starts fresh for
          // item counts, but keep the dedicated sealed-state key intact so
          // seals carry over to the next submission / user.
          try { localStorage.removeItem(getStorageKey()); } catch (e) {}
        });
      } else {
        // Standalone mode - use default inventory
        INVENTORY = parseInventory(DEFAULT_INVENTORY);
        enableTaggedAreas = Object.keys(sealableAreas).length > 0;
        buildUI();

        // Restore from localStorage in standalone mode
        var saved = loadState();
        if (saved) {
          if (saved.itemStates) itemStates = saved.itemStates;
          if (saved.taggedAreas) taggedAreas = saved.taggedAreas;
          if (saved.restockStatus) restockStatus = saved.restockStatus;
          if (saved.brokenSeals) brokenSeals = saved.brokenSeals;
        }

        // Layer in dedicated sealed-state store
        var sealData = loadSealState();
        if (sealData && sealData.taggedAreas) {
          var savedSealTs = (saved && saved.timestamp) || 0;
          var dedicatedSealTs = sealData.timestamp || 0;
          if (dedicatedSealTs >= savedSealTs) {
            taggedAreas = sealData.taggedAreas;
            if (sealData.brokenSeals) {
              brokenSeals = sealData.brokenSeals;
            }
          }
        }

        autoBreakOverdueSeals();
        clearUnsealedItemStates();

        buildUI();
        stateReady = true;
        saveState();
      }
    }
    
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
</body>
</html>
